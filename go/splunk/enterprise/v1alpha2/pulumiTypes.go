// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha2

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// IndexerCluster is the Schema for a Splunk Enterprise indexer cluster
type IndexerClusterType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
	Spec *IndexerClusterSpec `pulumi:"spec"`
	// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
	Status *IndexerClusterStatus `pulumi:"status"`
}

// IndexerClusterTypeInput is an input type that accepts IndexerClusterTypeArgs and IndexerClusterTypeOutput values.
// You can construct a concrete instance of `IndexerClusterTypeInput` via:
//
//          IndexerClusterTypeArgs{...}
type IndexerClusterTypeInput interface {
	pulumi.Input

	ToIndexerClusterTypeOutput() IndexerClusterTypeOutput
	ToIndexerClusterTypeOutputWithContext(context.Context) IndexerClusterTypeOutput
}

// IndexerCluster is the Schema for a Splunk Enterprise indexer cluster
type IndexerClusterTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
	Spec IndexerClusterSpecPtrInput `pulumi:"spec"`
	// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
	Status IndexerClusterStatusPtrInput `pulumi:"status"`
}

func (IndexerClusterTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterType)(nil)).Elem()
}

func (i IndexerClusterTypeArgs) ToIndexerClusterTypeOutput() IndexerClusterTypeOutput {
	return i.ToIndexerClusterTypeOutputWithContext(context.Background())
}

func (i IndexerClusterTypeArgs) ToIndexerClusterTypeOutputWithContext(ctx context.Context) IndexerClusterTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterTypeOutput)
}

// IndexerCluster is the Schema for a Splunk Enterprise indexer cluster
type IndexerClusterTypeOutput struct{ *pulumi.OutputState }

func (IndexerClusterTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterType)(nil)).Elem()
}

func (o IndexerClusterTypeOutput) ToIndexerClusterTypeOutput() IndexerClusterTypeOutput {
	return o
}

func (o IndexerClusterTypeOutput) ToIndexerClusterTypeOutputWithContext(ctx context.Context) IndexerClusterTypeOutput {
	return o
}

func (o IndexerClusterTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o IndexerClusterTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o IndexerClusterTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v IndexerClusterType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
func (o IndexerClusterTypeOutput) Spec() IndexerClusterSpecPtrOutput {
	return o.ApplyT(func(v IndexerClusterType) *IndexerClusterSpec { return v.Spec }).(IndexerClusterSpecPtrOutput)
}

// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
func (o IndexerClusterTypeOutput) Status() IndexerClusterStatusPtrOutput {
	return o.ApplyT(func(v IndexerClusterType) *IndexerClusterStatus { return v.Status }).(IndexerClusterStatusPtrOutput)
}

type IndexerClusterMetadata struct {
}

// IndexerClusterMetadataInput is an input type that accepts IndexerClusterMetadataArgs and IndexerClusterMetadataOutput values.
// You can construct a concrete instance of `IndexerClusterMetadataInput` via:
//
//          IndexerClusterMetadataArgs{...}
type IndexerClusterMetadataInput interface {
	pulumi.Input

	ToIndexerClusterMetadataOutput() IndexerClusterMetadataOutput
	ToIndexerClusterMetadataOutputWithContext(context.Context) IndexerClusterMetadataOutput
}

type IndexerClusterMetadataArgs struct {
}

func (IndexerClusterMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterMetadata)(nil)).Elem()
}

func (i IndexerClusterMetadataArgs) ToIndexerClusterMetadataOutput() IndexerClusterMetadataOutput {
	return i.ToIndexerClusterMetadataOutputWithContext(context.Background())
}

func (i IndexerClusterMetadataArgs) ToIndexerClusterMetadataOutputWithContext(ctx context.Context) IndexerClusterMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterMetadataOutput)
}

type IndexerClusterMetadataOutput struct{ *pulumi.OutputState }

func (IndexerClusterMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterMetadata)(nil)).Elem()
}

func (o IndexerClusterMetadataOutput) ToIndexerClusterMetadataOutput() IndexerClusterMetadataOutput {
	return o
}

func (o IndexerClusterMetadataOutput) ToIndexerClusterMetadataOutputWithContext(ctx context.Context) IndexerClusterMetadataOutput {
	return o
}

// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
type IndexerClusterSpec struct {
	// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
	Affinity *IndexerClusterSpecAffinity `pulumi:"affinity"`
	// Inline map of default.yml overrides used to initialize the environment
	Defaults *string `pulumi:"defaults"`
	// Full path or URL for one or more default.yml files, separated by commas
	DefaultsUrl *string `pulumi:"defaultsUrl"`
	// Storage capacity to request for /opt/splunk/etc persistent volume claims (default=”1Gi”)
	EtcStorage *string `pulumi:"etcStorage"`
	// Image to use for Splunk pod containers (overrides RELATED_IMAGE_SPLUNK_ENTERPRISE environment variables)
	Image *string `pulumi:"image"`
	// Sets pull policy for all images (either “Always” or the default: “IfNotPresent”)
	ImagePullPolicy *string `pulumi:"imagePullPolicy"`
	// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
	IndexerClusterRef *IndexerClusterSpecIndexerClusterRef `pulumi:"indexerClusterRef"`
	// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
	LicenseMasterRef *IndexerClusterSpecLicenseMasterRef `pulumi:"licenseMasterRef"`
	// Full path or URL for a Splunk Enterprise license file
	LicenseUrl *string `pulumi:"licenseUrl"`
	// Number of search head pods; a search head cluster will be created if > 1
	Replicas *int `pulumi:"replicas"`
	// resource requirements for the pod containers
	Resources *IndexerClusterSpecResources `pulumi:"resources"`
	// Name of Scheduler to use for pod placement (defaults to “default-scheduler”)
	SchedulerName *string `pulumi:"schedulerName"`
	// ServiceTemplate is a template used to create Kubernetes services
	ServiceTemplate *IndexerClusterSpecServiceTemplate `pulumi:"serviceTemplate"`
	// Name of StorageClass to use for persistent volume claims
	StorageClassName *string `pulumi:"storageClassName"`
	// Storage capacity to request for /opt/splunk/var persistent volume claims (default=”50Gi”)
	VarStorage *string `pulumi:"varStorage"`
	// List of one or more Kubernetes volumes. These will be mounted in all pod containers as as /mnt/<name>
	Volumes []IndexerClusterSpecVolumes `pulumi:"volumes"`
}

// IndexerClusterSpecInput is an input type that accepts IndexerClusterSpecArgs and IndexerClusterSpecOutput values.
// You can construct a concrete instance of `IndexerClusterSpecInput` via:
//
//          IndexerClusterSpecArgs{...}
type IndexerClusterSpecInput interface {
	pulumi.Input

	ToIndexerClusterSpecOutput() IndexerClusterSpecOutput
	ToIndexerClusterSpecOutputWithContext(context.Context) IndexerClusterSpecOutput
}

// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
type IndexerClusterSpecArgs struct {
	// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
	Affinity IndexerClusterSpecAffinityPtrInput `pulumi:"affinity"`
	// Inline map of default.yml overrides used to initialize the environment
	Defaults pulumi.StringPtrInput `pulumi:"defaults"`
	// Full path or URL for one or more default.yml files, separated by commas
	DefaultsUrl pulumi.StringPtrInput `pulumi:"defaultsUrl"`
	// Storage capacity to request for /opt/splunk/etc persistent volume claims (default=”1Gi”)
	EtcStorage pulumi.StringPtrInput `pulumi:"etcStorage"`
	// Image to use for Splunk pod containers (overrides RELATED_IMAGE_SPLUNK_ENTERPRISE environment variables)
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Sets pull policy for all images (either “Always” or the default: “IfNotPresent”)
	ImagePullPolicy pulumi.StringPtrInput `pulumi:"imagePullPolicy"`
	// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
	IndexerClusterRef IndexerClusterSpecIndexerClusterRefPtrInput `pulumi:"indexerClusterRef"`
	// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
	LicenseMasterRef IndexerClusterSpecLicenseMasterRefPtrInput `pulumi:"licenseMasterRef"`
	// Full path or URL for a Splunk Enterprise license file
	LicenseUrl pulumi.StringPtrInput `pulumi:"licenseUrl"`
	// Number of search head pods; a search head cluster will be created if > 1
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// resource requirements for the pod containers
	Resources IndexerClusterSpecResourcesPtrInput `pulumi:"resources"`
	// Name of Scheduler to use for pod placement (defaults to “default-scheduler”)
	SchedulerName pulumi.StringPtrInput `pulumi:"schedulerName"`
	// ServiceTemplate is a template used to create Kubernetes services
	ServiceTemplate IndexerClusterSpecServiceTemplatePtrInput `pulumi:"serviceTemplate"`
	// Name of StorageClass to use for persistent volume claims
	StorageClassName pulumi.StringPtrInput `pulumi:"storageClassName"`
	// Storage capacity to request for /opt/splunk/var persistent volume claims (default=”50Gi”)
	VarStorage pulumi.StringPtrInput `pulumi:"varStorage"`
	// List of one or more Kubernetes volumes. These will be mounted in all pod containers as as /mnt/<name>
	Volumes IndexerClusterSpecVolumesArrayInput `pulumi:"volumes"`
}

func (IndexerClusterSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpec)(nil)).Elem()
}

func (i IndexerClusterSpecArgs) ToIndexerClusterSpecOutput() IndexerClusterSpecOutput {
	return i.ToIndexerClusterSpecOutputWithContext(context.Background())
}

func (i IndexerClusterSpecArgs) ToIndexerClusterSpecOutputWithContext(ctx context.Context) IndexerClusterSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecOutput)
}

func (i IndexerClusterSpecArgs) ToIndexerClusterSpecPtrOutput() IndexerClusterSpecPtrOutput {
	return i.ToIndexerClusterSpecPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecArgs) ToIndexerClusterSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecOutput).ToIndexerClusterSpecPtrOutputWithContext(ctx)
}

// IndexerClusterSpecPtrInput is an input type that accepts IndexerClusterSpecArgs, IndexerClusterSpecPtr and IndexerClusterSpecPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecPtrInput` via:
//
//          IndexerClusterSpecArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecPtrOutput() IndexerClusterSpecPtrOutput
	ToIndexerClusterSpecPtrOutputWithContext(context.Context) IndexerClusterSpecPtrOutput
}

type indexerClusterSpecPtrType IndexerClusterSpecArgs

func IndexerClusterSpecPtr(v *IndexerClusterSpecArgs) IndexerClusterSpecPtrInput {
	return (*indexerClusterSpecPtrType)(v)
}

func (*indexerClusterSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpec)(nil)).Elem()
}

func (i *indexerClusterSpecPtrType) ToIndexerClusterSpecPtrOutput() IndexerClusterSpecPtrOutput {
	return i.ToIndexerClusterSpecPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecPtrType) ToIndexerClusterSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecPtrOutput)
}

// IndexerClusterSpec defines the desired state of a Splunk Enterprise indexer cluster
type IndexerClusterSpecOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpec)(nil)).Elem()
}

func (o IndexerClusterSpecOutput) ToIndexerClusterSpecOutput() IndexerClusterSpecOutput {
	return o
}

func (o IndexerClusterSpecOutput) ToIndexerClusterSpecOutputWithContext(ctx context.Context) IndexerClusterSpecOutput {
	return o
}

func (o IndexerClusterSpecOutput) ToIndexerClusterSpecPtrOutput() IndexerClusterSpecPtrOutput {
	return o.ToIndexerClusterSpecPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecOutput) ToIndexerClusterSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpec {
		return &v
	}).(IndexerClusterSpecPtrOutput)
}

// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
func (o IndexerClusterSpecOutput) Affinity() IndexerClusterSpecAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpecAffinity { return v.Affinity }).(IndexerClusterSpecAffinityPtrOutput)
}

// Inline map of default.yml overrides used to initialize the environment
func (o IndexerClusterSpecOutput) Defaults() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.Defaults }).(pulumi.StringPtrOutput)
}

// Full path or URL for one or more default.yml files, separated by commas
func (o IndexerClusterSpecOutput) DefaultsUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.DefaultsUrl }).(pulumi.StringPtrOutput)
}

// Storage capacity to request for /opt/splunk/etc persistent volume claims (default=”1Gi”)
func (o IndexerClusterSpecOutput) EtcStorage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.EtcStorage }).(pulumi.StringPtrOutput)
}

// Image to use for Splunk pod containers (overrides RELATED_IMAGE_SPLUNK_ENTERPRISE environment variables)
func (o IndexerClusterSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Sets pull policy for all images (either “Always” or the default: “IfNotPresent”)
func (o IndexerClusterSpecOutput) ImagePullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.ImagePullPolicy }).(pulumi.StringPtrOutput)
}

// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
func (o IndexerClusterSpecOutput) IndexerClusterRef() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpecIndexerClusterRef { return v.IndexerClusterRef }).(IndexerClusterSpecIndexerClusterRefPtrOutput)
}

// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
func (o IndexerClusterSpecOutput) LicenseMasterRef() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpecLicenseMasterRef { return v.LicenseMasterRef }).(IndexerClusterSpecLicenseMasterRefPtrOutput)
}

// Full path or URL for a Splunk Enterprise license file
func (o IndexerClusterSpecOutput) LicenseUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.LicenseUrl }).(pulumi.StringPtrOutput)
}

// Number of search head pods; a search head cluster will be created if > 1
func (o IndexerClusterSpecOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// resource requirements for the pod containers
func (o IndexerClusterSpecOutput) Resources() IndexerClusterSpecResourcesPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpecResources { return v.Resources }).(IndexerClusterSpecResourcesPtrOutput)
}

// Name of Scheduler to use for pod placement (defaults to “default-scheduler”)
func (o IndexerClusterSpecOutput) SchedulerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.SchedulerName }).(pulumi.StringPtrOutput)
}

// ServiceTemplate is a template used to create Kubernetes services
func (o IndexerClusterSpecOutput) ServiceTemplate() IndexerClusterSpecServiceTemplatePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *IndexerClusterSpecServiceTemplate { return v.ServiceTemplate }).(IndexerClusterSpecServiceTemplatePtrOutput)
}

// Name of StorageClass to use for persistent volume claims
func (o IndexerClusterSpecOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.StorageClassName }).(pulumi.StringPtrOutput)
}

// Storage capacity to request for /opt/splunk/var persistent volume claims (default=”50Gi”)
func (o IndexerClusterSpecOutput) VarStorage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpec) *string { return v.VarStorage }).(pulumi.StringPtrOutput)
}

// List of one or more Kubernetes volumes. These will be mounted in all pod containers as as /mnt/<name>
func (o IndexerClusterSpecOutput) Volumes() IndexerClusterSpecVolumesArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpec) []IndexerClusterSpecVolumes { return v.Volumes }).(IndexerClusterSpecVolumesArrayOutput)
}

type IndexerClusterSpecPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpec)(nil)).Elem()
}

func (o IndexerClusterSpecPtrOutput) ToIndexerClusterSpecPtrOutput() IndexerClusterSpecPtrOutput {
	return o
}

func (o IndexerClusterSpecPtrOutput) ToIndexerClusterSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecPtrOutput {
	return o
}

func (o IndexerClusterSpecPtrOutput) Elem() IndexerClusterSpecOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) IndexerClusterSpec { return *v }).(IndexerClusterSpecOutput)
}

// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
func (o IndexerClusterSpecPtrOutput) Affinity() IndexerClusterSpecAffinityPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *IndexerClusterSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(IndexerClusterSpecAffinityPtrOutput)
}

// Inline map of default.yml overrides used to initialize the environment
func (o IndexerClusterSpecPtrOutput) Defaults() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.Defaults
	}).(pulumi.StringPtrOutput)
}

// Full path or URL for one or more default.yml files, separated by commas
func (o IndexerClusterSpecPtrOutput) DefaultsUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.DefaultsUrl
	}).(pulumi.StringPtrOutput)
}

// Storage capacity to request for /opt/splunk/etc persistent volume claims (default=”1Gi”)
func (o IndexerClusterSpecPtrOutput) EtcStorage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.EtcStorage
	}).(pulumi.StringPtrOutput)
}

// Image to use for Splunk pod containers (overrides RELATED_IMAGE_SPLUNK_ENTERPRISE environment variables)
func (o IndexerClusterSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Sets pull policy for all images (either “Always” or the default: “IfNotPresent”)
func (o IndexerClusterSpecPtrOutput) ImagePullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.ImagePullPolicy
	}).(pulumi.StringPtrOutput)
}

// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
func (o IndexerClusterSpecPtrOutput) IndexerClusterRef() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *IndexerClusterSpecIndexerClusterRef {
		if v == nil {
			return nil
		}
		return v.IndexerClusterRef
	}).(IndexerClusterSpecIndexerClusterRefPtrOutput)
}

// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
func (o IndexerClusterSpecPtrOutput) LicenseMasterRef() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *IndexerClusterSpecLicenseMasterRef {
		if v == nil {
			return nil
		}
		return v.LicenseMasterRef
	}).(IndexerClusterSpecLicenseMasterRefPtrOutput)
}

// Full path or URL for a Splunk Enterprise license file
func (o IndexerClusterSpecPtrOutput) LicenseUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.LicenseUrl
	}).(pulumi.StringPtrOutput)
}

// Number of search head pods; a search head cluster will be created if > 1
func (o IndexerClusterSpecPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// resource requirements for the pod containers
func (o IndexerClusterSpecPtrOutput) Resources() IndexerClusterSpecResourcesPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *IndexerClusterSpecResources {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(IndexerClusterSpecResourcesPtrOutput)
}

// Name of Scheduler to use for pod placement (defaults to “default-scheduler”)
func (o IndexerClusterSpecPtrOutput) SchedulerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.SchedulerName
	}).(pulumi.StringPtrOutput)
}

// ServiceTemplate is a template used to create Kubernetes services
func (o IndexerClusterSpecPtrOutput) ServiceTemplate() IndexerClusterSpecServiceTemplatePtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *IndexerClusterSpecServiceTemplate {
		if v == nil {
			return nil
		}
		return v.ServiceTemplate
	}).(IndexerClusterSpecServiceTemplatePtrOutput)
}

// Name of StorageClass to use for persistent volume claims
func (o IndexerClusterSpecPtrOutput) StorageClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.StorageClassName
	}).(pulumi.StringPtrOutput)
}

// Storage capacity to request for /opt/splunk/var persistent volume claims (default=”50Gi”)
func (o IndexerClusterSpecPtrOutput) VarStorage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) *string {
		if v == nil {
			return nil
		}
		return v.VarStorage
	}).(pulumi.StringPtrOutput)
}

// List of one or more Kubernetes volumes. These will be mounted in all pod containers as as /mnt/<name>
func (o IndexerClusterSpecPtrOutput) Volumes() IndexerClusterSpecVolumesArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpec) []IndexerClusterSpecVolumes {
		if v == nil {
			return nil
		}
		return v.Volumes
	}).(IndexerClusterSpecVolumesArrayOutput)
}

// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
type IndexerClusterSpecAffinity struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity *IndexerClusterSpecAffinityNodeAffinity `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity *IndexerClusterSpecAffinityPodAffinity `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity *IndexerClusterSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// IndexerClusterSpecAffinityInput is an input type that accepts IndexerClusterSpecAffinityArgs and IndexerClusterSpecAffinityOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityInput` via:
//
//          IndexerClusterSpecAffinityArgs{...}
type IndexerClusterSpecAffinityInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityOutput() IndexerClusterSpecAffinityOutput
	ToIndexerClusterSpecAffinityOutputWithContext(context.Context) IndexerClusterSpecAffinityOutput
}

// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
type IndexerClusterSpecAffinityArgs struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity IndexerClusterSpecAffinityNodeAffinityPtrInput `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity IndexerClusterSpecAffinityPodAffinityPtrInput `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity IndexerClusterSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (IndexerClusterSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinity)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityArgs) ToIndexerClusterSpecAffinityOutput() IndexerClusterSpecAffinityOutput {
	return i.ToIndexerClusterSpecAffinityOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityArgs) ToIndexerClusterSpecAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityOutput)
}

func (i IndexerClusterSpecAffinityArgs) ToIndexerClusterSpecAffinityPtrOutput() IndexerClusterSpecAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityArgs) ToIndexerClusterSpecAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityOutput).ToIndexerClusterSpecAffinityPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPtrInput is an input type that accepts IndexerClusterSpecAffinityArgs, IndexerClusterSpecAffinityPtr and IndexerClusterSpecAffinityPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPtrInput` via:
//
//          IndexerClusterSpecAffinityArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPtrOutput() IndexerClusterSpecAffinityPtrOutput
	ToIndexerClusterSpecAffinityPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPtrOutput
}

type indexerClusterSpecAffinityPtrType IndexerClusterSpecAffinityArgs

func IndexerClusterSpecAffinityPtr(v *IndexerClusterSpecAffinityArgs) IndexerClusterSpecAffinityPtrInput {
	return (*indexerClusterSpecAffinityPtrType)(v)
}

func (*indexerClusterSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinity)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPtrType) ToIndexerClusterSpecAffinityPtrOutput() IndexerClusterSpecAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPtrType) ToIndexerClusterSpecAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPtrOutput)
}

// Kubernetes Affinity rules that control how pods are assigned to particular nodes.
type IndexerClusterSpecAffinityOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityOutput) ToIndexerClusterSpecAffinityOutput() IndexerClusterSpecAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityOutput) ToIndexerClusterSpecAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityOutput) ToIndexerClusterSpecAffinityPtrOutput() IndexerClusterSpecAffinityPtrOutput {
	return o.ToIndexerClusterSpecAffinityPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityOutput) ToIndexerClusterSpecAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinity) *IndexerClusterSpecAffinity {
		return &v
	}).(IndexerClusterSpecAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o IndexerClusterSpecAffinityOutput) NodeAffinity() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityNodeAffinity { return v.NodeAffinity }).(IndexerClusterSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o IndexerClusterSpecAffinityOutput) PodAffinity() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityPodAffinity { return v.PodAffinity }).(IndexerClusterSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o IndexerClusterSpecAffinityOutput) PodAntiAffinity() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(IndexerClusterSpecAffinityPodAntiAffinityPtrOutput)
}

type IndexerClusterSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPtrOutput) ToIndexerClusterSpecAffinityPtrOutput() IndexerClusterSpecAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPtrOutput) ToIndexerClusterSpecAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPtrOutput) Elem() IndexerClusterSpecAffinityOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinity) IndexerClusterSpecAffinity { return *v }).(IndexerClusterSpecAffinityOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o IndexerClusterSpecAffinityPtrOutput) NodeAffinity() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(IndexerClusterSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o IndexerClusterSpecAffinityPtrOutput) PodAffinity() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(IndexerClusterSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o IndexerClusterSpecAffinityPtrOutput) PodAntiAffinity() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinity) *IndexerClusterSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(IndexerClusterSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type IndexerClusterSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// IndexerClusterSpecAffinityNodeAffinityInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityArgs and IndexerClusterSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityArgs{...}
type IndexerClusterSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityOutput() IndexerClusterSpecAffinityNodeAffinityOutput
	ToIndexerClusterSpecAffinityNodeAffinityOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type IndexerClusterSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (IndexerClusterSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityArgs) ToIndexerClusterSpecAffinityNodeAffinityOutput() IndexerClusterSpecAffinityNodeAffinityOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityArgs) ToIndexerClusterSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityOutput)
}

func (i IndexerClusterSpecAffinityNodeAffinityArgs) ToIndexerClusterSpecAffinityNodeAffinityPtrOutput() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityArgs) ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityOutput).ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityNodeAffinityPtrInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityArgs, IndexerClusterSpecAffinityNodeAffinityPtr and IndexerClusterSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPtrInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPtrOutput() IndexerClusterSpecAffinityNodeAffinityPtrOutput
	ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPtrOutput
}

type indexerClusterSpecAffinityNodeAffinityPtrType IndexerClusterSpecAffinityNodeAffinityArgs

func IndexerClusterSpecAffinityNodeAffinityPtr(v *IndexerClusterSpecAffinityNodeAffinityArgs) IndexerClusterSpecAffinityNodeAffinityPtrInput {
	return (*indexerClusterSpecAffinityNodeAffinityPtrType)(v)
}

func (*indexerClusterSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityNodeAffinityPtrType) ToIndexerClusterSpecAffinityNodeAffinityPtrOutput() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityNodeAffinityPtrType) ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type IndexerClusterSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityOutput) ToIndexerClusterSpecAffinityNodeAffinityOutput() IndexerClusterSpecAffinityNodeAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityOutput) ToIndexerClusterSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityOutput) ToIndexerClusterSpecAffinityNodeAffinityPtrOutput() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o.ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityNodeAffinityOutput) ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinity) *IndexerClusterSpecAffinityNodeAffinity {
		return &v
	}).(IndexerClusterSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinity) []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
func (o IndexerClusterSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinity) *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type IndexerClusterSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPtrOutput) ToIndexerClusterSpecAffinityNodeAffinityPtrOutput() IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPtrOutput) ToIndexerClusterSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPtrOutput) Elem() IndexerClusterSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityNodeAffinity) IndexerClusterSpecAffinityNodeAffinity { return *v }).(IndexerClusterSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityNodeAffinity) []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
func (o IndexerClusterSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityNodeAffinity) *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// A node selector term, associated with the corresponding weight.
	Preference IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A node selector term, associated with the corresponding weight.
	Preference IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A node selector term, associated with the corresponding weight.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A node selector term, associated with the corresponding weight.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A node selector term, associated with the corresponding weight.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type indexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*indexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*indexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return *v
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//          IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToIndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// IndexerClusterSpecAffinityPodAffinityInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityArgs and IndexerClusterSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityArgs{...}
type IndexerClusterSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityOutput() IndexerClusterSpecAffinityPodAffinityOutput
	ToIndexerClusterSpecAffinityPodAffinityOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (IndexerClusterSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinity)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityArgs) ToIndexerClusterSpecAffinityPodAffinityOutput() IndexerClusterSpecAffinityPodAffinityOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityArgs) ToIndexerClusterSpecAffinityPodAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityOutput)
}

func (i IndexerClusterSpecAffinityPodAffinityArgs) ToIndexerClusterSpecAffinityPodAffinityPtrOutput() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityArgs) ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityOutput).ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAffinityPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityArgs, IndexerClusterSpecAffinityPodAffinityPtr and IndexerClusterSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPtrOutput() IndexerClusterSpecAffinityPodAffinityPtrOutput
	ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPtrOutput
}

type indexerClusterSpecAffinityPodAffinityPtrType IndexerClusterSpecAffinityPodAffinityArgs

func IndexerClusterSpecAffinityPodAffinityPtr(v *IndexerClusterSpecAffinityPodAffinityArgs) IndexerClusterSpecAffinityPodAffinityPtrInput {
	return (*indexerClusterSpecAffinityPodAffinityPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAffinityPtrType) ToIndexerClusterSpecAffinityPodAffinityPtrOutput() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAffinityPtrType) ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityOutput) ToIndexerClusterSpecAffinityPodAffinityOutput() IndexerClusterSpecAffinityPodAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityOutput) ToIndexerClusterSpecAffinityPodAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityOutput) ToIndexerClusterSpecAffinityPodAffinityPtrOutput() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAffinityOutput) ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinity) *IndexerClusterSpecAffinityPodAffinity {
		return &v
	}).(IndexerClusterSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinity) []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o IndexerClusterSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinity) []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type IndexerClusterSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPtrOutput) ToIndexerClusterSpecAffinityPodAffinityPtrOutput() IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPtrOutput) ToIndexerClusterSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPtrOutput) Elem() IndexerClusterSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinity) IndexerClusterSpecAffinityPodAffinity { return *v }).(IndexerClusterSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinity) []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o IndexerClusterSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinity) []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type indexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*indexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return *v
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs and IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs{...}
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
	ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs struct {
}

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type indexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*indexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return *v
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput is an input type that accepts IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs and IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput` via:
//
//          IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs{...}
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
	ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs struct {
}

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return i.ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// IndexerClusterSpecAffinityPodAntiAffinityInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityArgs and IndexerClusterSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityOutput() IndexerClusterSpecAffinityPodAntiAffinityOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityArgs) ToIndexerClusterSpecAffinityPodAntiAffinityOutput() IndexerClusterSpecAffinityPodAntiAffinityOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityArgs) ToIndexerClusterSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityOutput)
}

func (i IndexerClusterSpecAffinityPodAntiAffinityArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityOutput).ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAntiAffinityPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityArgs, IndexerClusterSpecAffinityPodAntiAffinityPtr and IndexerClusterSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPtrOutput
}

type indexerClusterSpecAffinityPodAntiAffinityPtrType IndexerClusterSpecAffinityPodAntiAffinityArgs

func IndexerClusterSpecAffinityPodAntiAffinityPtr(v *IndexerClusterSpecAffinityPodAntiAffinityArgs) IndexerClusterSpecAffinityPodAntiAffinityPtrInput {
	return (*indexerClusterSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAntiAffinityPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAntiAffinityPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type IndexerClusterSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) ToIndexerClusterSpecAffinityPodAntiAffinityOutput() IndexerClusterSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) ToIndexerClusterSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinity) *IndexerClusterSpecAffinityPodAntiAffinity {
		return &v
	}).(IndexerClusterSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinity) []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o IndexerClusterSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinity) []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) Elem() IndexerClusterSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinity) IndexerClusterSpecAffinityPodAntiAffinity {
		return *v
	}).(IndexerClusterSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
func (o IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinity) []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o IndexerClusterSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinity) []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type indexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*indexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return *v
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs and IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs struct {
}

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput {
	return o
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	LabelSelector IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type indexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*indexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*indexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *indexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return *v
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput is an input type that accepts IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs and IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput` via:
//
//          IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs{...}
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
	ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs struct {
}

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return i.ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsArgs) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels)(nil)).Elem()
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput() IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

func (o IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput) ToIndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput {
	return o
}

// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
type IndexerClusterSpecIndexerClusterRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// IndexerClusterSpecIndexerClusterRefInput is an input type that accepts IndexerClusterSpecIndexerClusterRefArgs and IndexerClusterSpecIndexerClusterRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecIndexerClusterRefInput` via:
//
//          IndexerClusterSpecIndexerClusterRefArgs{...}
type IndexerClusterSpecIndexerClusterRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecIndexerClusterRefOutput() IndexerClusterSpecIndexerClusterRefOutput
	ToIndexerClusterSpecIndexerClusterRefOutputWithContext(context.Context) IndexerClusterSpecIndexerClusterRefOutput
}

// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
type IndexerClusterSpecIndexerClusterRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (IndexerClusterSpecIndexerClusterRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecIndexerClusterRef)(nil)).Elem()
}

func (i IndexerClusterSpecIndexerClusterRefArgs) ToIndexerClusterSpecIndexerClusterRefOutput() IndexerClusterSpecIndexerClusterRefOutput {
	return i.ToIndexerClusterSpecIndexerClusterRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecIndexerClusterRefArgs) ToIndexerClusterSpecIndexerClusterRefOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecIndexerClusterRefOutput)
}

func (i IndexerClusterSpecIndexerClusterRefArgs) ToIndexerClusterSpecIndexerClusterRefPtrOutput() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return i.ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecIndexerClusterRefArgs) ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecIndexerClusterRefOutput).ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecIndexerClusterRefPtrInput is an input type that accepts IndexerClusterSpecIndexerClusterRefArgs, IndexerClusterSpecIndexerClusterRefPtr and IndexerClusterSpecIndexerClusterRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecIndexerClusterRefPtrInput` via:
//
//          IndexerClusterSpecIndexerClusterRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecIndexerClusterRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecIndexerClusterRefPtrOutput() IndexerClusterSpecIndexerClusterRefPtrOutput
	ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(context.Context) IndexerClusterSpecIndexerClusterRefPtrOutput
}

type indexerClusterSpecIndexerClusterRefPtrType IndexerClusterSpecIndexerClusterRefArgs

func IndexerClusterSpecIndexerClusterRefPtr(v *IndexerClusterSpecIndexerClusterRefArgs) IndexerClusterSpecIndexerClusterRefPtrInput {
	return (*indexerClusterSpecIndexerClusterRefPtrType)(v)
}

func (*indexerClusterSpecIndexerClusterRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecIndexerClusterRef)(nil)).Elem()
}

func (i *indexerClusterSpecIndexerClusterRefPtrType) ToIndexerClusterSpecIndexerClusterRefPtrOutput() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return i.ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecIndexerClusterRefPtrType) ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecIndexerClusterRefPtrOutput)
}

// IndexerClusterRef refers to a Splunk Enterprise indexer cluster managed by the operator within Kubernetes
type IndexerClusterSpecIndexerClusterRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecIndexerClusterRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecIndexerClusterRef)(nil)).Elem()
}

func (o IndexerClusterSpecIndexerClusterRefOutput) ToIndexerClusterSpecIndexerClusterRefOutput() IndexerClusterSpecIndexerClusterRefOutput {
	return o
}

func (o IndexerClusterSpecIndexerClusterRefOutput) ToIndexerClusterSpecIndexerClusterRefOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefOutput {
	return o
}

func (o IndexerClusterSpecIndexerClusterRefOutput) ToIndexerClusterSpecIndexerClusterRefPtrOutput() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o.ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecIndexerClusterRefOutput) ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *IndexerClusterSpecIndexerClusterRef {
		return &v
	}).(IndexerClusterSpecIndexerClusterRefPtrOutput)
}

// API version of the referent.
func (o IndexerClusterSpecIndexerClusterRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o IndexerClusterSpecIndexerClusterRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecIndexerClusterRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o IndexerClusterSpecIndexerClusterRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o IndexerClusterSpecIndexerClusterRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o IndexerClusterSpecIndexerClusterRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o IndexerClusterSpecIndexerClusterRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecIndexerClusterRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecIndexerClusterRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecIndexerClusterRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecIndexerClusterRef)(nil)).Elem()
}

func (o IndexerClusterSpecIndexerClusterRefPtrOutput) ToIndexerClusterSpecIndexerClusterRefPtrOutput() IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o
}

func (o IndexerClusterSpecIndexerClusterRefPtrOutput) ToIndexerClusterSpecIndexerClusterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecIndexerClusterRefPtrOutput {
	return o
}

func (o IndexerClusterSpecIndexerClusterRefPtrOutput) Elem() IndexerClusterSpecIndexerClusterRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) IndexerClusterSpecIndexerClusterRef { return *v }).(IndexerClusterSpecIndexerClusterRefOutput)
}

// API version of the referent.
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o IndexerClusterSpecIndexerClusterRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecIndexerClusterRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
type IndexerClusterSpecLicenseMasterRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// IndexerClusterSpecLicenseMasterRefInput is an input type that accepts IndexerClusterSpecLicenseMasterRefArgs and IndexerClusterSpecLicenseMasterRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecLicenseMasterRefInput` via:
//
//          IndexerClusterSpecLicenseMasterRefArgs{...}
type IndexerClusterSpecLicenseMasterRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecLicenseMasterRefOutput() IndexerClusterSpecLicenseMasterRefOutput
	ToIndexerClusterSpecLicenseMasterRefOutputWithContext(context.Context) IndexerClusterSpecLicenseMasterRefOutput
}

// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
type IndexerClusterSpecLicenseMasterRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (IndexerClusterSpecLicenseMasterRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecLicenseMasterRef)(nil)).Elem()
}

func (i IndexerClusterSpecLicenseMasterRefArgs) ToIndexerClusterSpecLicenseMasterRefOutput() IndexerClusterSpecLicenseMasterRefOutput {
	return i.ToIndexerClusterSpecLicenseMasterRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecLicenseMasterRefArgs) ToIndexerClusterSpecLicenseMasterRefOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecLicenseMasterRefOutput)
}

func (i IndexerClusterSpecLicenseMasterRefArgs) ToIndexerClusterSpecLicenseMasterRefPtrOutput() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return i.ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecLicenseMasterRefArgs) ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecLicenseMasterRefOutput).ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecLicenseMasterRefPtrInput is an input type that accepts IndexerClusterSpecLicenseMasterRefArgs, IndexerClusterSpecLicenseMasterRefPtr and IndexerClusterSpecLicenseMasterRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecLicenseMasterRefPtrInput` via:
//
//          IndexerClusterSpecLicenseMasterRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecLicenseMasterRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecLicenseMasterRefPtrOutput() IndexerClusterSpecLicenseMasterRefPtrOutput
	ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(context.Context) IndexerClusterSpecLicenseMasterRefPtrOutput
}

type indexerClusterSpecLicenseMasterRefPtrType IndexerClusterSpecLicenseMasterRefArgs

func IndexerClusterSpecLicenseMasterRefPtr(v *IndexerClusterSpecLicenseMasterRefArgs) IndexerClusterSpecLicenseMasterRefPtrInput {
	return (*indexerClusterSpecLicenseMasterRefPtrType)(v)
}

func (*indexerClusterSpecLicenseMasterRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecLicenseMasterRef)(nil)).Elem()
}

func (i *indexerClusterSpecLicenseMasterRefPtrType) ToIndexerClusterSpecLicenseMasterRefPtrOutput() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return i.ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecLicenseMasterRefPtrType) ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecLicenseMasterRefPtrOutput)
}

// LicenseMasterRef refers to a Splunk Enterprise license master managed by the operator within Kubernetes
type IndexerClusterSpecLicenseMasterRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecLicenseMasterRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecLicenseMasterRef)(nil)).Elem()
}

func (o IndexerClusterSpecLicenseMasterRefOutput) ToIndexerClusterSpecLicenseMasterRefOutput() IndexerClusterSpecLicenseMasterRefOutput {
	return o
}

func (o IndexerClusterSpecLicenseMasterRefOutput) ToIndexerClusterSpecLicenseMasterRefOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefOutput {
	return o
}

func (o IndexerClusterSpecLicenseMasterRefOutput) ToIndexerClusterSpecLicenseMasterRefPtrOutput() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o.ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecLicenseMasterRefOutput) ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *IndexerClusterSpecLicenseMasterRef {
		return &v
	}).(IndexerClusterSpecLicenseMasterRefPtrOutput)
}

// API version of the referent.
func (o IndexerClusterSpecLicenseMasterRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o IndexerClusterSpecLicenseMasterRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecLicenseMasterRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o IndexerClusterSpecLicenseMasterRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o IndexerClusterSpecLicenseMasterRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o IndexerClusterSpecLicenseMasterRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o IndexerClusterSpecLicenseMasterRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecLicenseMasterRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecLicenseMasterRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecLicenseMasterRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecLicenseMasterRef)(nil)).Elem()
}

func (o IndexerClusterSpecLicenseMasterRefPtrOutput) ToIndexerClusterSpecLicenseMasterRefPtrOutput() IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o
}

func (o IndexerClusterSpecLicenseMasterRefPtrOutput) ToIndexerClusterSpecLicenseMasterRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecLicenseMasterRefPtrOutput {
	return o
}

func (o IndexerClusterSpecLicenseMasterRefPtrOutput) Elem() IndexerClusterSpecLicenseMasterRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) IndexerClusterSpecLicenseMasterRef { return *v }).(IndexerClusterSpecLicenseMasterRefOutput)
}

// API version of the referent.
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o IndexerClusterSpecLicenseMasterRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecLicenseMasterRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// resource requirements for the pod containers
type IndexerClusterSpecResources struct {
	// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Limits map[string]string `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Requests map[string]string `pulumi:"requests"`
}

// IndexerClusterSpecResourcesInput is an input type that accepts IndexerClusterSpecResourcesArgs and IndexerClusterSpecResourcesOutput values.
// You can construct a concrete instance of `IndexerClusterSpecResourcesInput` via:
//
//          IndexerClusterSpecResourcesArgs{...}
type IndexerClusterSpecResourcesInput interface {
	pulumi.Input

	ToIndexerClusterSpecResourcesOutput() IndexerClusterSpecResourcesOutput
	ToIndexerClusterSpecResourcesOutputWithContext(context.Context) IndexerClusterSpecResourcesOutput
}

// resource requirements for the pod containers
type IndexerClusterSpecResourcesArgs struct {
	// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Limits pulumi.StringMapInput `pulumi:"limits"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Requests pulumi.StringMapInput `pulumi:"requests"`
}

func (IndexerClusterSpecResourcesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResources)(nil)).Elem()
}

func (i IndexerClusterSpecResourcesArgs) ToIndexerClusterSpecResourcesOutput() IndexerClusterSpecResourcesOutput {
	return i.ToIndexerClusterSpecResourcesOutputWithContext(context.Background())
}

func (i IndexerClusterSpecResourcesArgs) ToIndexerClusterSpecResourcesOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecResourcesOutput)
}

func (i IndexerClusterSpecResourcesArgs) ToIndexerClusterSpecResourcesPtrOutput() IndexerClusterSpecResourcesPtrOutput {
	return i.ToIndexerClusterSpecResourcesPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecResourcesArgs) ToIndexerClusterSpecResourcesPtrOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecResourcesOutput).ToIndexerClusterSpecResourcesPtrOutputWithContext(ctx)
}

// IndexerClusterSpecResourcesPtrInput is an input type that accepts IndexerClusterSpecResourcesArgs, IndexerClusterSpecResourcesPtr and IndexerClusterSpecResourcesPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecResourcesPtrInput` via:
//
//          IndexerClusterSpecResourcesArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecResourcesPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecResourcesPtrOutput() IndexerClusterSpecResourcesPtrOutput
	ToIndexerClusterSpecResourcesPtrOutputWithContext(context.Context) IndexerClusterSpecResourcesPtrOutput
}

type indexerClusterSpecResourcesPtrType IndexerClusterSpecResourcesArgs

func IndexerClusterSpecResourcesPtr(v *IndexerClusterSpecResourcesArgs) IndexerClusterSpecResourcesPtrInput {
	return (*indexerClusterSpecResourcesPtrType)(v)
}

func (*indexerClusterSpecResourcesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecResources)(nil)).Elem()
}

func (i *indexerClusterSpecResourcesPtrType) ToIndexerClusterSpecResourcesPtrOutput() IndexerClusterSpecResourcesPtrOutput {
	return i.ToIndexerClusterSpecResourcesPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecResourcesPtrType) ToIndexerClusterSpecResourcesPtrOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecResourcesPtrOutput)
}

// resource requirements for the pod containers
type IndexerClusterSpecResourcesOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecResourcesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResources)(nil)).Elem()
}

func (o IndexerClusterSpecResourcesOutput) ToIndexerClusterSpecResourcesOutput() IndexerClusterSpecResourcesOutput {
	return o
}

func (o IndexerClusterSpecResourcesOutput) ToIndexerClusterSpecResourcesOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesOutput {
	return o
}

func (o IndexerClusterSpecResourcesOutput) ToIndexerClusterSpecResourcesPtrOutput() IndexerClusterSpecResourcesPtrOutput {
	return o.ToIndexerClusterSpecResourcesPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecResourcesOutput) ToIndexerClusterSpecResourcesPtrOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecResources) *IndexerClusterSpecResources {
		return &v
	}).(IndexerClusterSpecResourcesPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
func (o IndexerClusterSpecResourcesOutput) Limits() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecResources) map[string]string { return v.Limits }).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
func (o IndexerClusterSpecResourcesOutput) Requests() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecResources) map[string]string { return v.Requests }).(pulumi.StringMapOutput)
}

type IndexerClusterSpecResourcesPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecResourcesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecResources)(nil)).Elem()
}

func (o IndexerClusterSpecResourcesPtrOutput) ToIndexerClusterSpecResourcesPtrOutput() IndexerClusterSpecResourcesPtrOutput {
	return o
}

func (o IndexerClusterSpecResourcesPtrOutput) ToIndexerClusterSpecResourcesPtrOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesPtrOutput {
	return o
}

func (o IndexerClusterSpecResourcesPtrOutput) Elem() IndexerClusterSpecResourcesOutput {
	return o.ApplyT(func(v *IndexerClusterSpecResources) IndexerClusterSpecResources { return *v }).(IndexerClusterSpecResourcesOutput)
}

// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
func (o IndexerClusterSpecResourcesPtrOutput) Limits() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecResources) map[string]string {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
func (o IndexerClusterSpecResourcesPtrOutput) Requests() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecResources) map[string]string {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.StringMapOutput)
}

// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesLimits struct {
}

// IndexerClusterSpecResourcesLimitsInput is an input type that accepts IndexerClusterSpecResourcesLimitsArgs and IndexerClusterSpecResourcesLimitsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecResourcesLimitsInput` via:
//
//          IndexerClusterSpecResourcesLimitsArgs{...}
type IndexerClusterSpecResourcesLimitsInput interface {
	pulumi.Input

	ToIndexerClusterSpecResourcesLimitsOutput() IndexerClusterSpecResourcesLimitsOutput
	ToIndexerClusterSpecResourcesLimitsOutputWithContext(context.Context) IndexerClusterSpecResourcesLimitsOutput
}

// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesLimitsArgs struct {
}

func (IndexerClusterSpecResourcesLimitsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResourcesLimits)(nil)).Elem()
}

func (i IndexerClusterSpecResourcesLimitsArgs) ToIndexerClusterSpecResourcesLimitsOutput() IndexerClusterSpecResourcesLimitsOutput {
	return i.ToIndexerClusterSpecResourcesLimitsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecResourcesLimitsArgs) ToIndexerClusterSpecResourcesLimitsOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesLimitsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecResourcesLimitsOutput)
}

// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesLimitsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecResourcesLimitsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResourcesLimits)(nil)).Elem()
}

func (o IndexerClusterSpecResourcesLimitsOutput) ToIndexerClusterSpecResourcesLimitsOutput() IndexerClusterSpecResourcesLimitsOutput {
	return o
}

func (o IndexerClusterSpecResourcesLimitsOutput) ToIndexerClusterSpecResourcesLimitsOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesLimitsOutput {
	return o
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesRequests struct {
}

// IndexerClusterSpecResourcesRequestsInput is an input type that accepts IndexerClusterSpecResourcesRequestsArgs and IndexerClusterSpecResourcesRequestsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecResourcesRequestsInput` via:
//
//          IndexerClusterSpecResourcesRequestsArgs{...}
type IndexerClusterSpecResourcesRequestsInput interface {
	pulumi.Input

	ToIndexerClusterSpecResourcesRequestsOutput() IndexerClusterSpecResourcesRequestsOutput
	ToIndexerClusterSpecResourcesRequestsOutputWithContext(context.Context) IndexerClusterSpecResourcesRequestsOutput
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesRequestsArgs struct {
}

func (IndexerClusterSpecResourcesRequestsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResourcesRequests)(nil)).Elem()
}

func (i IndexerClusterSpecResourcesRequestsArgs) ToIndexerClusterSpecResourcesRequestsOutput() IndexerClusterSpecResourcesRequestsOutput {
	return i.ToIndexerClusterSpecResourcesRequestsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecResourcesRequestsArgs) ToIndexerClusterSpecResourcesRequestsOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesRequestsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecResourcesRequestsOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
type IndexerClusterSpecResourcesRequestsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecResourcesRequestsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecResourcesRequests)(nil)).Elem()
}

func (o IndexerClusterSpecResourcesRequestsOutput) ToIndexerClusterSpecResourcesRequestsOutput() IndexerClusterSpecResourcesRequestsOutput {
	return o
}

func (o IndexerClusterSpecResourcesRequestsOutput) ToIndexerClusterSpecResourcesRequestsOutputWithContext(ctx context.Context) IndexerClusterSpecResourcesRequestsOutput {
	return o
}

// ServiceTemplate is a template used to create Kubernetes services
type IndexerClusterSpecServiceTemplate struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata map[string]interface{} `pulumi:"metadata"`
	// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec *IndexerClusterSpecServiceTemplateSpec `pulumi:"spec"`
	// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status *IndexerClusterSpecServiceTemplateStatus `pulumi:"status"`
}

// IndexerClusterSpecServiceTemplateInput is an input type that accepts IndexerClusterSpecServiceTemplateArgs and IndexerClusterSpecServiceTemplateOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateInput` via:
//
//          IndexerClusterSpecServiceTemplateArgs{...}
type IndexerClusterSpecServiceTemplateInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateOutput() IndexerClusterSpecServiceTemplateOutput
	ToIndexerClusterSpecServiceTemplateOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateOutput
}

// ServiceTemplate is a template used to create Kubernetes services
type IndexerClusterSpecServiceTemplateArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata pulumi.MapInput `pulumi:"metadata"`
	// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Spec IndexerClusterSpecServiceTemplateSpecPtrInput `pulumi:"spec"`
	// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	Status IndexerClusterSpecServiceTemplateStatusPtrInput `pulumi:"status"`
}

func (IndexerClusterSpecServiceTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplate)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateArgs) ToIndexerClusterSpecServiceTemplateOutput() IndexerClusterSpecServiceTemplateOutput {
	return i.ToIndexerClusterSpecServiceTemplateOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateArgs) ToIndexerClusterSpecServiceTemplateOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateOutput)
}

func (i IndexerClusterSpecServiceTemplateArgs) ToIndexerClusterSpecServiceTemplatePtrOutput() IndexerClusterSpecServiceTemplatePtrOutput {
	return i.ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateArgs) ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateOutput).ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplatePtrInput is an input type that accepts IndexerClusterSpecServiceTemplateArgs, IndexerClusterSpecServiceTemplatePtr and IndexerClusterSpecServiceTemplatePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplatePtrInput` via:
//
//          IndexerClusterSpecServiceTemplateArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplatePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplatePtrOutput() IndexerClusterSpecServiceTemplatePtrOutput
	ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplatePtrOutput
}

type indexerClusterSpecServiceTemplatePtrType IndexerClusterSpecServiceTemplateArgs

func IndexerClusterSpecServiceTemplatePtr(v *IndexerClusterSpecServiceTemplateArgs) IndexerClusterSpecServiceTemplatePtrInput {
	return (*indexerClusterSpecServiceTemplatePtrType)(v)
}

func (*indexerClusterSpecServiceTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplate)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplatePtrType) ToIndexerClusterSpecServiceTemplatePtrOutput() IndexerClusterSpecServiceTemplatePtrOutput {
	return i.ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplatePtrType) ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplatePtrOutput)
}

// ServiceTemplate is a template used to create Kubernetes services
type IndexerClusterSpecServiceTemplateOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplate)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateOutput) ToIndexerClusterSpecServiceTemplateOutput() IndexerClusterSpecServiceTemplateOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateOutput) ToIndexerClusterSpecServiceTemplateOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateOutput) ToIndexerClusterSpecServiceTemplatePtrOutput() IndexerClusterSpecServiceTemplatePtrOutput {
	return o.ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateOutput) ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplatePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) *IndexerClusterSpecServiceTemplate {
		return &v
	}).(IndexerClusterSpecServiceTemplatePtrOutput)
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o IndexerClusterSpecServiceTemplateOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecServiceTemplateOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o IndexerClusterSpecServiceTemplateOutput) Metadata() pulumi.MapOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) map[string]interface{} { return v.Metadata }).(pulumi.MapOutput)
}

// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o IndexerClusterSpecServiceTemplateOutput) Spec() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) *IndexerClusterSpecServiceTemplateSpec { return v.Spec }).(IndexerClusterSpecServiceTemplateSpecPtrOutput)
}

// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o IndexerClusterSpecServiceTemplateOutput) Status() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplate) *IndexerClusterSpecServiceTemplateStatus { return v.Status }).(IndexerClusterSpecServiceTemplateStatusPtrOutput)
}

type IndexerClusterSpecServiceTemplatePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplate)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplatePtrOutput) ToIndexerClusterSpecServiceTemplatePtrOutput() IndexerClusterSpecServiceTemplatePtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplatePtrOutput) ToIndexerClusterSpecServiceTemplatePtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplatePtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplatePtrOutput) Elem() IndexerClusterSpecServiceTemplateOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) IndexerClusterSpecServiceTemplate { return *v }).(IndexerClusterSpecServiceTemplateOutput)
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o IndexerClusterSpecServiceTemplatePtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o IndexerClusterSpecServiceTemplatePtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o IndexerClusterSpecServiceTemplatePtrOutput) Metadata() pulumi.MapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(pulumi.MapOutput)
}

// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o IndexerClusterSpecServiceTemplatePtrOutput) Spec() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) *IndexerClusterSpecServiceTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(IndexerClusterSpecServiceTemplateSpecPtrOutput)
}

// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
func (o IndexerClusterSpecServiceTemplatePtrOutput) Status() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplate) *IndexerClusterSpecServiceTemplateStatus {
		if v == nil {
			return nil
		}
		return v.Status
	}).(IndexerClusterSpecServiceTemplateStatusPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type IndexerClusterSpecServiceTemplateMetadata struct {
}

// IndexerClusterSpecServiceTemplateMetadataInput is an input type that accepts IndexerClusterSpecServiceTemplateMetadataArgs and IndexerClusterSpecServiceTemplateMetadataOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateMetadataInput` via:
//
//          IndexerClusterSpecServiceTemplateMetadataArgs{...}
type IndexerClusterSpecServiceTemplateMetadataInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateMetadataOutput() IndexerClusterSpecServiceTemplateMetadataOutput
	ToIndexerClusterSpecServiceTemplateMetadataOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateMetadataOutput
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type IndexerClusterSpecServiceTemplateMetadataArgs struct {
}

func (IndexerClusterSpecServiceTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateMetadata)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateMetadataArgs) ToIndexerClusterSpecServiceTemplateMetadataOutput() IndexerClusterSpecServiceTemplateMetadataOutput {
	return i.ToIndexerClusterSpecServiceTemplateMetadataOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateMetadataArgs) ToIndexerClusterSpecServiceTemplateMetadataOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateMetadataOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
type IndexerClusterSpecServiceTemplateMetadataOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateMetadata)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateMetadataOutput) ToIndexerClusterSpecServiceTemplateMetadataOutput() IndexerClusterSpecServiceTemplateMetadataOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateMetadataOutput) ToIndexerClusterSpecServiceTemplateMetadataOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateMetadataOutput {
	return o
}

// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateSpec struct {
	// clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP *string `pulumi:"clusterIP"`
	// externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
	ExternalIPs []string `pulumi:"externalIPs"`
	// externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
	ExternalName *string `pulumi:"externalName"`
	// externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
	HealthCheckNodePort *int `pulumi:"healthCheckNodePort"`
	// ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
	IpFamily *string `pulumi:"ipFamily"`
	// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
	LoadBalancerSourceRanges []string `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports []IndexerClusterSpecServiceTemplateSpecPorts `pulumi:"ports"`
	// publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
	PublishNotReadyAddresses *bool `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector map[string]string `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity *string `pulumi:"sessionAffinity"`
	// sessionAffinityConfig contains the configurations of session affinity.
	SessionAffinityConfig *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig `pulumi:"sessionAffinityConfig"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type *string `pulumi:"type"`
}

// IndexerClusterSpecServiceTemplateSpecInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecArgs and IndexerClusterSpecServiceTemplateSpecOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecArgs{...}
type IndexerClusterSpecServiceTemplateSpecInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecOutput() IndexerClusterSpecServiceTemplateSpecOutput
	ToIndexerClusterSpecServiceTemplateSpecOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecOutput
}

// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateSpecArgs struct {
	// clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
	ExternalName pulumi.StringPtrInput `pulumi:"externalName"`
	// externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
	HealthCheckNodePort pulumi.IntPtrInput `pulumi:"healthCheckNodePort"`
	// ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
	IpFamily pulumi.StringPtrInput `pulumi:"ipFamily"`
	// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
	LoadBalancerSourceRanges pulumi.StringArrayInput `pulumi:"loadBalancerSourceRanges"`
	// The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	Ports IndexerClusterSpecServiceTemplateSpecPortsArrayInput `pulumi:"ports"`
	// publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
	PublishNotReadyAddresses pulumi.BoolPtrInput `pulumi:"publishNotReadyAddresses"`
	// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
	Selector pulumi.StringMapInput `pulumi:"selector"`
	// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	SessionAffinity pulumi.StringPtrInput `pulumi:"sessionAffinity"`
	// sessionAffinityConfig contains the configurations of session affinity.
	SessionAffinityConfig IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrInput `pulumi:"sessionAffinityConfig"`
	// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (IndexerClusterSpecServiceTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpec)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecArgs) ToIndexerClusterSpecServiceTemplateSpecOutput() IndexerClusterSpecServiceTemplateSpecOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecArgs) ToIndexerClusterSpecServiceTemplateSpecOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecOutput)
}

func (i IndexerClusterSpecServiceTemplateSpecArgs) ToIndexerClusterSpecServiceTemplateSpecPtrOutput() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecArgs) ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecOutput).ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateSpecPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecArgs, IndexerClusterSpecServiceTemplateSpecPtr and IndexerClusterSpecServiceTemplateSpecPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateSpecPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecPtrOutput() IndexerClusterSpecServiceTemplateSpecPtrOutput
	ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecPtrOutput
}

type indexerClusterSpecServiceTemplateSpecPtrType IndexerClusterSpecServiceTemplateSpecArgs

func IndexerClusterSpecServiceTemplateSpecPtr(v *IndexerClusterSpecServiceTemplateSpecArgs) IndexerClusterSpecServiceTemplateSpecPtrInput {
	return (*indexerClusterSpecServiceTemplateSpecPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpec)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateSpecPtrType) ToIndexerClusterSpecServiceTemplateSpecPtrOutput() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateSpecPtrType) ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPtrOutput)
}

// Spec defines the behavior of a service. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateSpecOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpec)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecOutput) ToIndexerClusterSpecServiceTemplateSpecOutput() IndexerClusterSpecServiceTemplateSpecOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecOutput) ToIndexerClusterSpecServiceTemplateSpecOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecOutput) ToIndexerClusterSpecServiceTemplateSpecPtrOutput() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateSpecOutput) ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *IndexerClusterSpecServiceTemplateSpec {
		return &v
	}).(IndexerClusterSpecServiceTemplateSpecPtrOutput)
}

// clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
func (o IndexerClusterSpecServiceTemplateSpecOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
func (o IndexerClusterSpecServiceTemplateSpecOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.ExternalName }).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
func (o IndexerClusterSpecServiceTemplateSpecOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
func (o IndexerClusterSpecServiceTemplateSpecOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *int { return v.HealthCheckNodePort }).(pulumi.IntPtrOutput)
}

// ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
func (o IndexerClusterSpecServiceTemplateSpecOutput) IpFamily() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.IpFamily }).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
func (o IndexerClusterSpecServiceTemplateSpecOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
func (o IndexerClusterSpecServiceTemplateSpecOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) []string { return v.LoadBalancerSourceRanges }).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecOutput) Ports() IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) []IndexerClusterSpecServiceTemplateSpecPorts {
		return v.Ports
	}).(IndexerClusterSpecServiceTemplateSpecPortsArrayOutput)
}

// publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
func (o IndexerClusterSpecServiceTemplateSpecOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *bool { return v.PublishNotReadyAddresses }).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o IndexerClusterSpecServiceTemplateSpecOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) map[string]string { return v.Selector }).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.SessionAffinity }).(pulumi.StringPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
func (o IndexerClusterSpecServiceTemplateSpecOutput) SessionAffinityConfig() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig {
		return v.SessionAffinityConfig
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o IndexerClusterSpecServiceTemplateSpecOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpec) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpec)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ToIndexerClusterSpecServiceTemplateSpecPtrOutput() IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ToIndexerClusterSpecServiceTemplateSpecPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) Elem() IndexerClusterSpecServiceTemplateSpecOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) IndexerClusterSpecServiceTemplateSpec { return *v }).(IndexerClusterSpecServiceTemplateSpecOutput)
}

// clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ExternalName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalName
	}).(pulumi.StringPtrOutput)
}

// externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) HealthCheckNodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *int {
		if v == nil {
			return nil
		}
		return v.HealthCheckNodePort
	}).(pulumi.IntPtrOutput)
}

// ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) IpFamily() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.IpFamily
	}).(pulumi.StringPtrOutput)
}

// Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) LoadBalancerSourceRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) []string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerSourceRanges
	}).(pulumi.StringArrayOutput)
}

// The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) Ports() IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) []IndexerClusterSpecServiceTemplateSpecPorts {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(IndexerClusterSpecServiceTemplateSpecPortsArrayOutput)
}

// publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) PublishNotReadyAddresses() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *bool {
		if v == nil {
			return nil
		}
		return v.PublishNotReadyAddresses
	}).(pulumi.BoolPtrOutput)
}

// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) Selector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringMapOutput)
}

// Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) SessionAffinity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.SessionAffinity
	}).(pulumi.StringPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) SessionAffinityConfig() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig {
		if v == nil {
			return nil
		}
		return v.SessionAffinityConfig
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput)
}

// type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
func (o IndexerClusterSpecServiceTemplateSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ServicePort contains information on service's port.
type IndexerClusterSpecServiceTemplateSpecPorts struct {
	// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
	Name *string `pulumi:"name"`
	// The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort *int `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port int `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
	Protocol *string `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort *IndexerClusterSpecServiceTemplateSpecPortsTargetPort `pulumi:"targetPort"`
}

// IndexerClusterSpecServiceTemplateSpecPortsInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecPortsArgs and IndexerClusterSpecServiceTemplateSpecPortsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecPortsInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecPortsArgs{...}
type IndexerClusterSpecServiceTemplateSpecPortsInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecPortsOutput() IndexerClusterSpecServiceTemplateSpecPortsOutput
	ToIndexerClusterSpecServiceTemplateSpecPortsOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecPortsOutput
}

// ServicePort contains information on service's port.
type IndexerClusterSpecServiceTemplateSpecPortsArgs struct {
	// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	NodePort pulumi.IntPtrInput `pulumi:"nodePort"`
	// The port that will be exposed by this service.
	Port pulumi.IntInput `pulumi:"port"`
	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	TargetPort IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrInput `pulumi:"targetPort"`
}

func (IndexerClusterSpecServiceTemplateSpecPortsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecPorts)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecPortsArgs) ToIndexerClusterSpecServiceTemplateSpecPortsOutput() IndexerClusterSpecServiceTemplateSpecPortsOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPortsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecPortsArgs) ToIndexerClusterSpecServiceTemplateSpecPortsOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPortsOutput)
}

// IndexerClusterSpecServiceTemplateSpecPortsArrayInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecPortsArray and IndexerClusterSpecServiceTemplateSpecPortsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecPortsArrayInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecPortsArray{ IndexerClusterSpecServiceTemplateSpecPortsArgs{...} }
type IndexerClusterSpecServiceTemplateSpecPortsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutput() IndexerClusterSpecServiceTemplateSpecPortsArrayOutput
	ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecPortsArrayOutput
}

type IndexerClusterSpecServiceTemplateSpecPortsArray []IndexerClusterSpecServiceTemplateSpecPortsInput

func (IndexerClusterSpecServiceTemplateSpecPortsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecServiceTemplateSpecPorts)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecPortsArray) ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutput() IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecPortsArray) ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPortsArrayOutput)
}

// ServicePort contains information on service's port.
type IndexerClusterSpecServiceTemplateSpecPortsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecPortsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecPorts)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) ToIndexerClusterSpecServiceTemplateSpecPortsOutput() IndexerClusterSpecServiceTemplateSpecPortsOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) ToIndexerClusterSpecServiceTemplateSpecPortsOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsOutput {
	return o
}

// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPorts) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) NodePort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPorts) *int { return v.NodePort }).(pulumi.IntPtrOutput)
}

// The port that will be exposed by this service.
func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPorts) int { return v.Port }).(pulumi.IntOutput)
}

// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPorts) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
func (o IndexerClusterSpecServiceTemplateSpecPortsOutput) TargetPort() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPorts) *IndexerClusterSpecServiceTemplateSpecPortsTargetPort {
		return v.TargetPort
	}).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecPortsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecPortsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecServiceTemplateSpecPorts)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecPortsArrayOutput) ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutput() IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsArrayOutput) ToIndexerClusterSpecServiceTemplateSpecPortsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsArrayOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecServiceTemplateSpecPortsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecServiceTemplateSpecPorts {
		return vs[0].([]IndexerClusterSpecServiceTemplateSpecPorts)[vs[1].(int)]
	}).(IndexerClusterSpecServiceTemplateSpecPortsOutput)
}

type IndexerClusterSpecServiceTemplateSpecPortsTargetPort struct {
}

// IndexerClusterSpecServiceTemplateSpecPortsTargetPortInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs and IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecPortsTargetPortInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs{...}
type IndexerClusterSpecServiceTemplateSpecPortsTargetPortInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput
	ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput
}

type IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs struct {
}

func (IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecPortsTargetPort)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput)
}

func (i IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput).ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs, IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtr and IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput
	ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput
}

type indexerClusterSpecServiceTemplateSpecPortsTargetPortPtrType IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs

func IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtr(v *IndexerClusterSpecServiceTemplateSpecPortsTargetPortArgs) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrInput {
	return (*indexerClusterSpecServiceTemplateSpecPortsTargetPortPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateSpecPortsTargetPortPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecPortsTargetPort)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateSpecPortsTargetPortPtrType) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateSpecPortsTargetPortPtrType) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecPortsTargetPort)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecPortsTargetPort) *IndexerClusterSpecServiceTemplateSpecPortsTargetPort {
		return &v
	}).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecPortsTargetPort)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput() IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput) ToIndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput) Elem() IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpecPortsTargetPort) IndexerClusterSpecServiceTemplateSpecPortsTargetPort {
		return *v
	}).(IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput)
}

// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
type IndexerClusterSpecServiceTemplateSpecSelector struct {
}

// IndexerClusterSpecServiceTemplateSpecSelectorInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecSelectorArgs and IndexerClusterSpecServiceTemplateSpecSelectorOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecSelectorInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecSelectorArgs{...}
type IndexerClusterSpecServiceTemplateSpecSelectorInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecSelectorOutput() IndexerClusterSpecServiceTemplateSpecSelectorOutput
	ToIndexerClusterSpecServiceTemplateSpecSelectorOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecSelectorOutput
}

// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
type IndexerClusterSpecServiceTemplateSpecSelectorArgs struct {
}

func (IndexerClusterSpecServiceTemplateSpecSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSelector)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecSelectorArgs) ToIndexerClusterSpecServiceTemplateSpecSelectorOutput() IndexerClusterSpecServiceTemplateSpecSelectorOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSelectorOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecSelectorArgs) ToIndexerClusterSpecServiceTemplateSpecSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSelectorOutput)
}

// Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
type IndexerClusterSpecServiceTemplateSpecSelectorOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSelector)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecSelectorOutput) ToIndexerClusterSpecServiceTemplateSpecSelectorOutput() IndexerClusterSpecServiceTemplateSpecSelectorOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSelectorOutput) ToIndexerClusterSpecServiceTemplateSpecSelectorOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSelectorOutput {
	return o
}

// sessionAffinityConfig contains the configurations of session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig struct {
	// clientIP contains the configurations of Client IP based session affinity.
	ClientIP *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP `pulumi:"clientIP"`
}

// IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs and IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs{...}
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput
	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput
}

// sessionAffinityConfig contains the configurations of session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs struct {
	// clientIP contains the configurations of Client IP based session affinity.
	ClientIP IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrInput `pulumi:"clientIP"`
}

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput)
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput).ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs, IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtr and IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput
	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput
}

type indexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrType IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs

func IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtr(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigArgs) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrInput {
	return (*indexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrType) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrType) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput)
}

// sessionAffinityConfig contains the configurations of session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig {
		return &v
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput) ClientIP() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP {
		return v.ClientIP
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput) Elem() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig {
		return *v
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput) ClientIP() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfig) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP {
		if v == nil {
			return nil
		}
		return v.ClientIP
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs and IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs{...}
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput
	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput
}

// clientIP contains the configurations of Client IP based session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs struct {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput)
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput).ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs, IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtr and IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput
	ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput
}

type indexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrType IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs

func IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtr(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPArgs) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrInput {
	return (*indexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrType) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrType) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput)
}

// clientIP contains the configurations of Client IP based session affinity.
type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP) *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP {
		return &v
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP) *int {
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput) ToIndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput) Elem() IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP) IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP {
		return *v
	}).(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput)
}

// timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
func (o IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIP) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateStatus struct {
	// LoadBalancer contains the current status of the load-balancer, if one is present.
	LoadBalancer *IndexerClusterSpecServiceTemplateStatusLoadBalancer `pulumi:"loadBalancer"`
}

// IndexerClusterSpecServiceTemplateStatusInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusArgs and IndexerClusterSpecServiceTemplateStatusOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusArgs{...}
type IndexerClusterSpecServiceTemplateStatusInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusOutput() IndexerClusterSpecServiceTemplateStatusOutput
	ToIndexerClusterSpecServiceTemplateStatusOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusOutput
}

// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateStatusArgs struct {
	// LoadBalancer contains the current status of the load-balancer, if one is present.
	LoadBalancer IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrInput `pulumi:"loadBalancer"`
}

func (IndexerClusterSpecServiceTemplateStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatus)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateStatusArgs) ToIndexerClusterSpecServiceTemplateStatusOutput() IndexerClusterSpecServiceTemplateStatusOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusArgs) ToIndexerClusterSpecServiceTemplateStatusOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusOutput)
}

func (i IndexerClusterSpecServiceTemplateStatusArgs) ToIndexerClusterSpecServiceTemplateStatusPtrOutput() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusArgs) ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusOutput).ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateStatusPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusArgs, IndexerClusterSpecServiceTemplateStatusPtr and IndexerClusterSpecServiceTemplateStatusPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateStatusPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusPtrOutput() IndexerClusterSpecServiceTemplateStatusPtrOutput
	ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusPtrOutput
}

type indexerClusterSpecServiceTemplateStatusPtrType IndexerClusterSpecServiceTemplateStatusArgs

func IndexerClusterSpecServiceTemplateStatusPtr(v *IndexerClusterSpecServiceTemplateStatusArgs) IndexerClusterSpecServiceTemplateStatusPtrInput {
	return (*indexerClusterSpecServiceTemplateStatusPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateStatus)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateStatusPtrType) ToIndexerClusterSpecServiceTemplateStatusPtrOutput() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateStatusPtrType) ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusPtrOutput)
}

// Most recently observed status of the service. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
type IndexerClusterSpecServiceTemplateStatusOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatus)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusOutput) ToIndexerClusterSpecServiceTemplateStatusOutput() IndexerClusterSpecServiceTemplateStatusOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusOutput) ToIndexerClusterSpecServiceTemplateStatusOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusOutput) ToIndexerClusterSpecServiceTemplateStatusPtrOutput() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateStatusOutput) ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatus) *IndexerClusterSpecServiceTemplateStatus {
		return &v
	}).(IndexerClusterSpecServiceTemplateStatusPtrOutput)
}

// LoadBalancer contains the current status of the load-balancer, if one is present.
func (o IndexerClusterSpecServiceTemplateStatusOutput) LoadBalancer() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatus) *IndexerClusterSpecServiceTemplateStatusLoadBalancer {
		return v.LoadBalancer
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput)
}

type IndexerClusterSpecServiceTemplateStatusPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateStatus)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusPtrOutput) ToIndexerClusterSpecServiceTemplateStatusPtrOutput() IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusPtrOutput) ToIndexerClusterSpecServiceTemplateStatusPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusPtrOutput) Elem() IndexerClusterSpecServiceTemplateStatusOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateStatus) IndexerClusterSpecServiceTemplateStatus { return *v }).(IndexerClusterSpecServiceTemplateStatusOutput)
}

// LoadBalancer contains the current status of the load-balancer, if one is present.
func (o IndexerClusterSpecServiceTemplateStatusPtrOutput) LoadBalancer() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateStatus) *IndexerClusterSpecServiceTemplateStatusLoadBalancer {
		if v == nil {
			return nil
		}
		return v.LoadBalancer
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput)
}

// LoadBalancer contains the current status of the load-balancer, if one is present.
type IndexerClusterSpecServiceTemplateStatusLoadBalancer struct {
	// Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
	Ingress []IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress `pulumi:"ingress"`
}

// IndexerClusterSpecServiceTemplateStatusLoadBalancerInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs and IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusLoadBalancerInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs{...}
type IndexerClusterSpecServiceTemplateStatusLoadBalancerInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput
	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput
}

// LoadBalancer contains the current status of the load-balancer, if one is present.
type IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs struct {
	// Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
	Ingress IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayInput `pulumi:"ingress"`
}

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatusLoadBalancer)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput)
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput).ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(ctx)
}

// IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs, IndexerClusterSpecServiceTemplateStatusLoadBalancerPtr and IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput
	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput
}

type indexerClusterSpecServiceTemplateStatusLoadBalancerPtrType IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs

func IndexerClusterSpecServiceTemplateStatusLoadBalancerPtr(v *IndexerClusterSpecServiceTemplateStatusLoadBalancerArgs) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrInput {
	return (*indexerClusterSpecServiceTemplateStatusLoadBalancerPtrType)(v)
}

func (*indexerClusterSpecServiceTemplateStatusLoadBalancerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateStatusLoadBalancer)(nil)).Elem()
}

func (i *indexerClusterSpecServiceTemplateStatusLoadBalancerPtrType) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecServiceTemplateStatusLoadBalancerPtrType) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput)
}

// LoadBalancer contains the current status of the load-balancer, if one is present.
type IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatusLoadBalancer)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatusLoadBalancer) *IndexerClusterSpecServiceTemplateStatusLoadBalancer {
		return &v
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput)
}

// Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput) Ingress() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatusLoadBalancer) []IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress {
		return v.Ingress
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput)
}

type IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecServiceTemplateStatusLoadBalancer)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput) Elem() IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateStatusLoadBalancer) IndexerClusterSpecServiceTemplateStatusLoadBalancer {
		return *v
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput)
}

// Ingress is a list containing ingress points for the load-balancer. Traffic intended for the service should be sent to these ingress points.
func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput) Ingress() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecServiceTemplateStatusLoadBalancer) []IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput)
}

// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress struct {
	// Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)
	Hostname *string `pulumi:"hostname"`
	// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)
	Ip *string `pulumi:"ip"`
}

// IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs and IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs{...}
type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput
	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput
}

// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs struct {
	// Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)
	Ip pulumi.StringPtrInput `pulumi:"ip"`
}

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput)
}

// IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayInput is an input type that accepts IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray and IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayInput` via:
//
//          IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray{ IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArgs{...} }
type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput
	ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutputWithContext(context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput
}

type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray []IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressInput

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress)(nil)).Elem()
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return i.ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArray) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput)
}

// LoadBalancerIngress represents the status of a load-balancer ingress point: traffic intended for the service should be sent to an ingress point.
type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput {
	return o
}

// Hostname is set for load-balancer ingress points that are DNS based (typically AWS load-balancers)
func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// IP is set for load-balancer ingress points that are IP based (typically GCE or OpenStack load-balancers)
func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress)(nil)).Elem()
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput() IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput) ToIndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutputWithContext(ctx context.Context) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput {
	return o
}

func (o IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress {
		return vs[0].([]IndexerClusterSpecServiceTemplateStatusLoadBalancerIngress)[vs[1].(int)]
	}).(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput)
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
type IndexerClusterSpecVolumes struct {
	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	AwsElasticBlockStore *IndexerClusterSpecVolumesAwsElasticBlockStore `pulumi:"awsElasticBlockStore"`
	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	AzureDisk *IndexerClusterSpecVolumesAzureDisk `pulumi:"azureDisk"`
	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	AzureFile *IndexerClusterSpecVolumesAzureFile `pulumi:"azureFile"`
	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs *IndexerClusterSpecVolumesCephfs `pulumi:"cephfs"`
	// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	Cinder *IndexerClusterSpecVolumesCinder `pulumi:"cinder"`
	// ConfigMap represents a configMap that should populate this volume
	ConfigMap *IndexerClusterSpecVolumesConfigMap `pulumi:"configMap"`
	// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
	Csi *IndexerClusterSpecVolumesCsi `pulumi:"csi"`
	// DownwardAPI represents downward API about the pod that should populate this volume
	DownwardAPI *IndexerClusterSpecVolumesDownwardAPI `pulumi:"downwardAPI"`
	// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	EmptyDir *IndexerClusterSpecVolumesEmptyDir `pulumi:"emptyDir"`
	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
	Fc *IndexerClusterSpecVolumesFc `pulumi:"fc"`
	// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
	FlexVolume *IndexerClusterSpecVolumesFlexVolume `pulumi:"flexVolume"`
	// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
	Flocker *IndexerClusterSpecVolumesFlocker `pulumi:"flocker"`
	// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	GcePersistentDisk *IndexerClusterSpecVolumesGcePersistentDisk `pulumi:"gcePersistentDisk"`
	// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
	GitRepo *IndexerClusterSpecVolumesGitRepo `pulumi:"gitRepo"`
	// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
	Glusterfs *IndexerClusterSpecVolumesGlusterfs `pulumi:"glusterfs"`
	// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
	HostPath *IndexerClusterSpecVolumesHostPath `pulumi:"hostPath"`
	// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
	Iscsi *IndexerClusterSpecVolumesIscsi `pulumi:"iscsi"`
	// Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
	// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Nfs *IndexerClusterSpecVolumesNfs `pulumi:"nfs"`
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	PersistentVolumeClaim *IndexerClusterSpecVolumesPersistentVolumeClaim `pulumi:"persistentVolumeClaim"`
	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
	PhotonPersistentDisk *IndexerClusterSpecVolumesPhotonPersistentDisk `pulumi:"photonPersistentDisk"`
	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
	PortworxVolume *IndexerClusterSpecVolumesPortworxVolume `pulumi:"portworxVolume"`
	// Items for all in one resources secrets, configmaps, and downward API
	Projected *IndexerClusterSpecVolumesProjected `pulumi:"projected"`
	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte *IndexerClusterSpecVolumesQuobyte `pulumi:"quobyte"`
	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
	Rbd *IndexerClusterSpecVolumesRbd `pulumi:"rbd"`
	// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
	ScaleIO *IndexerClusterSpecVolumesScaleIO `pulumi:"scaleIO"`
	// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	Secret *IndexerClusterSpecVolumesSecret `pulumi:"secret"`
	// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
	Storageos *IndexerClusterSpecVolumesStorageos `pulumi:"storageos"`
	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	VsphereVolume *IndexerClusterSpecVolumesVsphereVolume `pulumi:"vsphereVolume"`
}

// IndexerClusterSpecVolumesInput is an input type that accepts IndexerClusterSpecVolumesArgs and IndexerClusterSpecVolumesOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesInput` via:
//
//          IndexerClusterSpecVolumesArgs{...}
type IndexerClusterSpecVolumesInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesOutput() IndexerClusterSpecVolumesOutput
	ToIndexerClusterSpecVolumesOutputWithContext(context.Context) IndexerClusterSpecVolumesOutput
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
type IndexerClusterSpecVolumesArgs struct {
	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	AwsElasticBlockStore IndexerClusterSpecVolumesAwsElasticBlockStorePtrInput `pulumi:"awsElasticBlockStore"`
	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	AzureDisk IndexerClusterSpecVolumesAzureDiskPtrInput `pulumi:"azureDisk"`
	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	AzureFile IndexerClusterSpecVolumesAzureFilePtrInput `pulumi:"azureFile"`
	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs IndexerClusterSpecVolumesCephfsPtrInput `pulumi:"cephfs"`
	// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	Cinder IndexerClusterSpecVolumesCinderPtrInput `pulumi:"cinder"`
	// ConfigMap represents a configMap that should populate this volume
	ConfigMap IndexerClusterSpecVolumesConfigMapPtrInput `pulumi:"configMap"`
	// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
	Csi IndexerClusterSpecVolumesCsiPtrInput `pulumi:"csi"`
	// DownwardAPI represents downward API about the pod that should populate this volume
	DownwardAPI IndexerClusterSpecVolumesDownwardAPIPtrInput `pulumi:"downwardAPI"`
	// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	EmptyDir IndexerClusterSpecVolumesEmptyDirPtrInput `pulumi:"emptyDir"`
	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
	Fc IndexerClusterSpecVolumesFcPtrInput `pulumi:"fc"`
	// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
	FlexVolume IndexerClusterSpecVolumesFlexVolumePtrInput `pulumi:"flexVolume"`
	// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
	Flocker IndexerClusterSpecVolumesFlockerPtrInput `pulumi:"flocker"`
	// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	GcePersistentDisk IndexerClusterSpecVolumesGcePersistentDiskPtrInput `pulumi:"gcePersistentDisk"`
	// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
	GitRepo IndexerClusterSpecVolumesGitRepoPtrInput `pulumi:"gitRepo"`
	// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
	Glusterfs IndexerClusterSpecVolumesGlusterfsPtrInput `pulumi:"glusterfs"`
	// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
	HostPath IndexerClusterSpecVolumesHostPathPtrInput `pulumi:"hostPath"`
	// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
	Iscsi IndexerClusterSpecVolumesIscsiPtrInput `pulumi:"iscsi"`
	// Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
	// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Nfs IndexerClusterSpecVolumesNfsPtrInput `pulumi:"nfs"`
	// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	PersistentVolumeClaim IndexerClusterSpecVolumesPersistentVolumeClaimPtrInput `pulumi:"persistentVolumeClaim"`
	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
	PhotonPersistentDisk IndexerClusterSpecVolumesPhotonPersistentDiskPtrInput `pulumi:"photonPersistentDisk"`
	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
	PortworxVolume IndexerClusterSpecVolumesPortworxVolumePtrInput `pulumi:"portworxVolume"`
	// Items for all in one resources secrets, configmaps, and downward API
	Projected IndexerClusterSpecVolumesProjectedPtrInput `pulumi:"projected"`
	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte IndexerClusterSpecVolumesQuobytePtrInput `pulumi:"quobyte"`
	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
	Rbd IndexerClusterSpecVolumesRbdPtrInput `pulumi:"rbd"`
	// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
	ScaleIO IndexerClusterSpecVolumesScaleIOPtrInput `pulumi:"scaleIO"`
	// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	Secret IndexerClusterSpecVolumesSecretPtrInput `pulumi:"secret"`
	// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
	Storageos IndexerClusterSpecVolumesStorageosPtrInput `pulumi:"storageos"`
	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	VsphereVolume IndexerClusterSpecVolumesVsphereVolumePtrInput `pulumi:"vsphereVolume"`
}

func (IndexerClusterSpecVolumesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumes)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesArgs) ToIndexerClusterSpecVolumesOutput() IndexerClusterSpecVolumesOutput {
	return i.ToIndexerClusterSpecVolumesOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesArgs) ToIndexerClusterSpecVolumesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesOutput)
}

// IndexerClusterSpecVolumesArrayInput is an input type that accepts IndexerClusterSpecVolumesArray and IndexerClusterSpecVolumesArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesArrayInput` via:
//
//          IndexerClusterSpecVolumesArray{ IndexerClusterSpecVolumesArgs{...} }
type IndexerClusterSpecVolumesArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesArrayOutput() IndexerClusterSpecVolumesArrayOutput
	ToIndexerClusterSpecVolumesArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesArrayOutput
}

type IndexerClusterSpecVolumesArray []IndexerClusterSpecVolumesInput

func (IndexerClusterSpecVolumesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumes)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesArray) ToIndexerClusterSpecVolumesArrayOutput() IndexerClusterSpecVolumesArrayOutput {
	return i.ToIndexerClusterSpecVolumesArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesArray) ToIndexerClusterSpecVolumesArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesArrayOutput)
}

// Volume represents a named volume in a pod that may be accessed by any container in the pod.
type IndexerClusterSpecVolumesOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumes)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesOutput) ToIndexerClusterSpecVolumesOutput() IndexerClusterSpecVolumesOutput {
	return o
}

func (o IndexerClusterSpecVolumesOutput) ToIndexerClusterSpecVolumesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesOutput {
	return o
}

// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
func (o IndexerClusterSpecVolumesOutput) AwsElasticBlockStore() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesAwsElasticBlockStore {
		return v.AwsElasticBlockStore
	}).(IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput)
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
func (o IndexerClusterSpecVolumesOutput) AzureDisk() IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesAzureDisk { return v.AzureDisk }).(IndexerClusterSpecVolumesAzureDiskPtrOutput)
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
func (o IndexerClusterSpecVolumesOutput) AzureFile() IndexerClusterSpecVolumesAzureFilePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesAzureFile { return v.AzureFile }).(IndexerClusterSpecVolumesAzureFilePtrOutput)
}

// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
func (o IndexerClusterSpecVolumesOutput) Cephfs() IndexerClusterSpecVolumesCephfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesCephfs { return v.Cephfs }).(IndexerClusterSpecVolumesCephfsPtrOutput)
}

// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesOutput) Cinder() IndexerClusterSpecVolumesCinderPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesCinder { return v.Cinder }).(IndexerClusterSpecVolumesCinderPtrOutput)
}

// ConfigMap represents a configMap that should populate this volume
func (o IndexerClusterSpecVolumesOutput) ConfigMap() IndexerClusterSpecVolumesConfigMapPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesConfigMap { return v.ConfigMap }).(IndexerClusterSpecVolumesConfigMapPtrOutput)
}

// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
func (o IndexerClusterSpecVolumesOutput) Csi() IndexerClusterSpecVolumesCsiPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesCsi { return v.Csi }).(IndexerClusterSpecVolumesCsiPtrOutput)
}

// DownwardAPI represents downward API about the pod that should populate this volume
func (o IndexerClusterSpecVolumesOutput) DownwardAPI() IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesDownwardAPI { return v.DownwardAPI }).(IndexerClusterSpecVolumesDownwardAPIPtrOutput)
}

// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
func (o IndexerClusterSpecVolumesOutput) EmptyDir() IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesEmptyDir { return v.EmptyDir }).(IndexerClusterSpecVolumesEmptyDirPtrOutput)
}

// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
func (o IndexerClusterSpecVolumesOutput) Fc() IndexerClusterSpecVolumesFcPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesFc { return v.Fc }).(IndexerClusterSpecVolumesFcPtrOutput)
}

// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
func (o IndexerClusterSpecVolumesOutput) FlexVolume() IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesFlexVolume { return v.FlexVolume }).(IndexerClusterSpecVolumesFlexVolumePtrOutput)
}

// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
func (o IndexerClusterSpecVolumesOutput) Flocker() IndexerClusterSpecVolumesFlockerPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesFlocker { return v.Flocker }).(IndexerClusterSpecVolumesFlockerPtrOutput)
}

// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesOutput) GcePersistentDisk() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesGcePersistentDisk {
		return v.GcePersistentDisk
	}).(IndexerClusterSpecVolumesGcePersistentDiskPtrOutput)
}

// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
func (o IndexerClusterSpecVolumesOutput) GitRepo() IndexerClusterSpecVolumesGitRepoPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesGitRepo { return v.GitRepo }).(IndexerClusterSpecVolumesGitRepoPtrOutput)
}

// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
func (o IndexerClusterSpecVolumesOutput) Glusterfs() IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesGlusterfs { return v.Glusterfs }).(IndexerClusterSpecVolumesGlusterfsPtrOutput)
}

// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
func (o IndexerClusterSpecVolumesOutput) HostPath() IndexerClusterSpecVolumesHostPathPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesHostPath { return v.HostPath }).(IndexerClusterSpecVolumesHostPathPtrOutput)
}

// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
func (o IndexerClusterSpecVolumesOutput) Iscsi() IndexerClusterSpecVolumesIscsiPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesIscsi { return v.Iscsi }).(IndexerClusterSpecVolumesIscsiPtrOutput)
}

// Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o IndexerClusterSpecVolumesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) string { return v.Name }).(pulumi.StringOutput)
}

// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesOutput) Nfs() IndexerClusterSpecVolumesNfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesNfs { return v.Nfs }).(IndexerClusterSpecVolumesNfsPtrOutput)
}

// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
func (o IndexerClusterSpecVolumesOutput) PersistentVolumeClaim() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesPersistentVolumeClaim {
		return v.PersistentVolumeClaim
	}).(IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput)
}

// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
func (o IndexerClusterSpecVolumesOutput) PhotonPersistentDisk() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesPhotonPersistentDisk {
		return v.PhotonPersistentDisk
	}).(IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput)
}

// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
func (o IndexerClusterSpecVolumesOutput) PortworxVolume() IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesPortworxVolume { return v.PortworxVolume }).(IndexerClusterSpecVolumesPortworxVolumePtrOutput)
}

// Items for all in one resources secrets, configmaps, and downward API
func (o IndexerClusterSpecVolumesOutput) Projected() IndexerClusterSpecVolumesProjectedPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesProjected { return v.Projected }).(IndexerClusterSpecVolumesProjectedPtrOutput)
}

// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
func (o IndexerClusterSpecVolumesOutput) Quobyte() IndexerClusterSpecVolumesQuobytePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesQuobyte { return v.Quobyte }).(IndexerClusterSpecVolumesQuobytePtrOutput)
}

// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
func (o IndexerClusterSpecVolumesOutput) Rbd() IndexerClusterSpecVolumesRbdPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesRbd { return v.Rbd }).(IndexerClusterSpecVolumesRbdPtrOutput)
}

// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
func (o IndexerClusterSpecVolumesOutput) ScaleIO() IndexerClusterSpecVolumesScaleIOPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesScaleIO { return v.ScaleIO }).(IndexerClusterSpecVolumesScaleIOPtrOutput)
}

// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
func (o IndexerClusterSpecVolumesOutput) Secret() IndexerClusterSpecVolumesSecretPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesSecret { return v.Secret }).(IndexerClusterSpecVolumesSecretPtrOutput)
}

// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
func (o IndexerClusterSpecVolumesOutput) Storageos() IndexerClusterSpecVolumesStorageosPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesStorageos { return v.Storageos }).(IndexerClusterSpecVolumesStorageosPtrOutput)
}

// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
func (o IndexerClusterSpecVolumesOutput) VsphereVolume() IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumes) *IndexerClusterSpecVolumesVsphereVolume { return v.VsphereVolume }).(IndexerClusterSpecVolumesVsphereVolumePtrOutput)
}

type IndexerClusterSpecVolumesArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumes)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesArrayOutput) ToIndexerClusterSpecVolumesArrayOutput() IndexerClusterSpecVolumesArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesArrayOutput) ToIndexerClusterSpecVolumesArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumes {
		return vs[0].([]IndexerClusterSpecVolumes)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesOutput)
}

// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
type IndexerClusterSpecVolumesAwsElasticBlockStore struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType *string `pulumi:"fsType"`
	// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
	Partition *int `pulumi:"partition"`
	// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	ReadOnly *bool `pulumi:"readOnly"`
	// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	VolumeID string `pulumi:"volumeID"`
}

// IndexerClusterSpecVolumesAwsElasticBlockStoreInput is an input type that accepts IndexerClusterSpecVolumesAwsElasticBlockStoreArgs and IndexerClusterSpecVolumesAwsElasticBlockStoreOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAwsElasticBlockStoreInput` via:
//
//          IndexerClusterSpecVolumesAwsElasticBlockStoreArgs{...}
type IndexerClusterSpecVolumesAwsElasticBlockStoreInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutput() IndexerClusterSpecVolumesAwsElasticBlockStoreOutput
	ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutputWithContext(context.Context) IndexerClusterSpecVolumesAwsElasticBlockStoreOutput
}

// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
type IndexerClusterSpecVolumesAwsElasticBlockStoreArgs struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
	Partition pulumi.IntPtrInput `pulumi:"partition"`
	// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	VolumeID pulumi.StringInput `pulumi:"volumeID"`
}

func (IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAwsElasticBlockStore)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutput() IndexerClusterSpecVolumesAwsElasticBlockStoreOutput {
	return i.ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStoreOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAwsElasticBlockStoreOutput)
}

func (i IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return i.ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAwsElasticBlockStoreOutput).ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesAwsElasticBlockStorePtrInput is an input type that accepts IndexerClusterSpecVolumesAwsElasticBlockStoreArgs, IndexerClusterSpecVolumesAwsElasticBlockStorePtr and IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAwsElasticBlockStorePtrInput` via:
//
//          IndexerClusterSpecVolumesAwsElasticBlockStoreArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesAwsElasticBlockStorePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput
	ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput
}

type indexerClusterSpecVolumesAwsElasticBlockStorePtrType IndexerClusterSpecVolumesAwsElasticBlockStoreArgs

func IndexerClusterSpecVolumesAwsElasticBlockStorePtr(v *IndexerClusterSpecVolumesAwsElasticBlockStoreArgs) IndexerClusterSpecVolumesAwsElasticBlockStorePtrInput {
	return (*indexerClusterSpecVolumesAwsElasticBlockStorePtrType)(v)
}

func (*indexerClusterSpecVolumesAwsElasticBlockStorePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAwsElasticBlockStore)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesAwsElasticBlockStorePtrType) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return i.ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesAwsElasticBlockStorePtrType) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput)
}

// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
type IndexerClusterSpecVolumesAwsElasticBlockStoreOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAwsElasticBlockStore)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutput() IndexerClusterSpecVolumesAwsElasticBlockStoreOutput {
	return o
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStoreOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStoreOutput {
	return o
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return o.ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAwsElasticBlockStore) *IndexerClusterSpecVolumesAwsElasticBlockStore {
		return &v
	}).(IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAwsElasticBlockStore) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAwsElasticBlockStore) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAwsElasticBlockStore) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
func (o IndexerClusterSpecVolumesAwsElasticBlockStoreOutput) VolumeID() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAwsElasticBlockStore) string { return v.VolumeID }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAwsElasticBlockStore)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput() IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) ToIndexerClusterSpecVolumesAwsElasticBlockStorePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) Elem() IndexerClusterSpecVolumesAwsElasticBlockStoreOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAwsElasticBlockStore) IndexerClusterSpecVolumesAwsElasticBlockStore {
		return *v
	}).(IndexerClusterSpecVolumesAwsElasticBlockStoreOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAwsElasticBlockStore) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAwsElasticBlockStore) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAwsElasticBlockStore) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
func (o IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput) VolumeID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAwsElasticBlockStore) *string {
		if v == nil {
			return nil
		}
		return &v.VolumeID
	}).(pulumi.StringPtrOutput)
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureDisk struct {
	// Host Caching mode: None, Read Only, Read Write.
	CachingMode *string `pulumi:"cachingMode"`
	// The Name of the data disk in the blob storage
	DiskName string `pulumi:"diskName"`
	// The URI the data disk in the blob storage
	DiskURI string `pulumi:"diskURI"`
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType *string `pulumi:"fsType"`
	// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
	Kind *string `pulumi:"kind"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
}

// IndexerClusterSpecVolumesAzureDiskInput is an input type that accepts IndexerClusterSpecVolumesAzureDiskArgs and IndexerClusterSpecVolumesAzureDiskOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAzureDiskInput` via:
//
//          IndexerClusterSpecVolumesAzureDiskArgs{...}
type IndexerClusterSpecVolumesAzureDiskInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAzureDiskOutput() IndexerClusterSpecVolumesAzureDiskOutput
	ToIndexerClusterSpecVolumesAzureDiskOutputWithContext(context.Context) IndexerClusterSpecVolumesAzureDiskOutput
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureDiskArgs struct {
	// Host Caching mode: None, Read Only, Read Write.
	CachingMode pulumi.StringPtrInput `pulumi:"cachingMode"`
	// The Name of the data disk in the blob storage
	DiskName pulumi.StringInput `pulumi:"diskName"`
	// The URI the data disk in the blob storage
	DiskURI pulumi.StringInput `pulumi:"diskURI"`
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
}

func (IndexerClusterSpecVolumesAzureDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAzureDisk)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesAzureDiskArgs) ToIndexerClusterSpecVolumesAzureDiskOutput() IndexerClusterSpecVolumesAzureDiskOutput {
	return i.ToIndexerClusterSpecVolumesAzureDiskOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAzureDiskArgs) ToIndexerClusterSpecVolumesAzureDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureDiskOutput)
}

func (i IndexerClusterSpecVolumesAzureDiskArgs) ToIndexerClusterSpecVolumesAzureDiskPtrOutput() IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAzureDiskArgs) ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureDiskOutput).ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesAzureDiskPtrInput is an input type that accepts IndexerClusterSpecVolumesAzureDiskArgs, IndexerClusterSpecVolumesAzureDiskPtr and IndexerClusterSpecVolumesAzureDiskPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAzureDiskPtrInput` via:
//
//          IndexerClusterSpecVolumesAzureDiskArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesAzureDiskPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAzureDiskPtrOutput() IndexerClusterSpecVolumesAzureDiskPtrOutput
	ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesAzureDiskPtrOutput
}

type indexerClusterSpecVolumesAzureDiskPtrType IndexerClusterSpecVolumesAzureDiskArgs

func IndexerClusterSpecVolumesAzureDiskPtr(v *IndexerClusterSpecVolumesAzureDiskArgs) IndexerClusterSpecVolumesAzureDiskPtrInput {
	return (*indexerClusterSpecVolumesAzureDiskPtrType)(v)
}

func (*indexerClusterSpecVolumesAzureDiskPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAzureDisk)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesAzureDiskPtrType) ToIndexerClusterSpecVolumesAzureDiskPtrOutput() IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesAzureDiskPtrType) ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureDiskPtrOutput)
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureDiskOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAzureDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAzureDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAzureDiskOutput) ToIndexerClusterSpecVolumesAzureDiskOutput() IndexerClusterSpecVolumesAzureDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureDiskOutput) ToIndexerClusterSpecVolumesAzureDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureDiskOutput) ToIndexerClusterSpecVolumesAzureDiskPtrOutput() IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return o.ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesAzureDiskOutput) ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) *IndexerClusterSpecVolumesAzureDisk {
		return &v
	}).(IndexerClusterSpecVolumesAzureDiskPtrOutput)
}

// Host Caching mode: None, Read Only, Read Write.
func (o IndexerClusterSpecVolumesAzureDiskOutput) CachingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) *string { return v.CachingMode }).(pulumi.StringPtrOutput)
}

// The Name of the data disk in the blob storage
func (o IndexerClusterSpecVolumesAzureDiskOutput) DiskName() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) string { return v.DiskName }).(pulumi.StringOutput)
}

// The URI the data disk in the blob storage
func (o IndexerClusterSpecVolumesAzureDiskOutput) DiskURI() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) string { return v.DiskURI }).(pulumi.StringOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesAzureDiskOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
func (o IndexerClusterSpecVolumesAzureDiskOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesAzureDiskOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureDisk) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesAzureDiskPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAzureDiskPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAzureDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) ToIndexerClusterSpecVolumesAzureDiskPtrOutput() IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) ToIndexerClusterSpecVolumesAzureDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) Elem() IndexerClusterSpecVolumesAzureDiskOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) IndexerClusterSpecVolumesAzureDisk { return *v }).(IndexerClusterSpecVolumesAzureDiskOutput)
}

// Host Caching mode: None, Read Only, Read Write.
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) CachingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *string {
		if v == nil {
			return nil
		}
		return v.CachingMode
	}).(pulumi.StringPtrOutput)
}

// The Name of the data disk in the blob storage
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) DiskName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *string {
		if v == nil {
			return nil
		}
		return &v.DiskName
	}).(pulumi.StringPtrOutput)
}

// The URI the data disk in the blob storage
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) DiskURI() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *string {
		if v == nil {
			return nil
		}
		return &v.DiskURI
	}).(pulumi.StringPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesAzureDiskPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureDisk) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureFile struct {
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// the name of secret that contains Azure Storage Account Name and Key
	SecretName string `pulumi:"secretName"`
	// Share Name
	ShareName string `pulumi:"shareName"`
}

// IndexerClusterSpecVolumesAzureFileInput is an input type that accepts IndexerClusterSpecVolumesAzureFileArgs and IndexerClusterSpecVolumesAzureFileOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAzureFileInput` via:
//
//          IndexerClusterSpecVolumesAzureFileArgs{...}
type IndexerClusterSpecVolumesAzureFileInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAzureFileOutput() IndexerClusterSpecVolumesAzureFileOutput
	ToIndexerClusterSpecVolumesAzureFileOutputWithContext(context.Context) IndexerClusterSpecVolumesAzureFileOutput
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureFileArgs struct {
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// the name of secret that contains Azure Storage Account Name and Key
	SecretName pulumi.StringInput `pulumi:"secretName"`
	// Share Name
	ShareName pulumi.StringInput `pulumi:"shareName"`
}

func (IndexerClusterSpecVolumesAzureFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAzureFile)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesAzureFileArgs) ToIndexerClusterSpecVolumesAzureFileOutput() IndexerClusterSpecVolumesAzureFileOutput {
	return i.ToIndexerClusterSpecVolumesAzureFileOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAzureFileArgs) ToIndexerClusterSpecVolumesAzureFileOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureFileOutput)
}

func (i IndexerClusterSpecVolumesAzureFileArgs) ToIndexerClusterSpecVolumesAzureFilePtrOutput() IndexerClusterSpecVolumesAzureFilePtrOutput {
	return i.ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesAzureFileArgs) ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureFileOutput).ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesAzureFilePtrInput is an input type that accepts IndexerClusterSpecVolumesAzureFileArgs, IndexerClusterSpecVolumesAzureFilePtr and IndexerClusterSpecVolumesAzureFilePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesAzureFilePtrInput` via:
//
//          IndexerClusterSpecVolumesAzureFileArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesAzureFilePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesAzureFilePtrOutput() IndexerClusterSpecVolumesAzureFilePtrOutput
	ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesAzureFilePtrOutput
}

type indexerClusterSpecVolumesAzureFilePtrType IndexerClusterSpecVolumesAzureFileArgs

func IndexerClusterSpecVolumesAzureFilePtr(v *IndexerClusterSpecVolumesAzureFileArgs) IndexerClusterSpecVolumesAzureFilePtrInput {
	return (*indexerClusterSpecVolumesAzureFilePtrType)(v)
}

func (*indexerClusterSpecVolumesAzureFilePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAzureFile)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesAzureFilePtrType) ToIndexerClusterSpecVolumesAzureFilePtrOutput() IndexerClusterSpecVolumesAzureFilePtrOutput {
	return i.ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesAzureFilePtrType) ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesAzureFilePtrOutput)
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
type IndexerClusterSpecVolumesAzureFileOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAzureFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesAzureFile)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAzureFileOutput) ToIndexerClusterSpecVolumesAzureFileOutput() IndexerClusterSpecVolumesAzureFileOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureFileOutput) ToIndexerClusterSpecVolumesAzureFileOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFileOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureFileOutput) ToIndexerClusterSpecVolumesAzureFilePtrOutput() IndexerClusterSpecVolumesAzureFilePtrOutput {
	return o.ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesAzureFileOutput) ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFilePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureFile) *IndexerClusterSpecVolumesAzureFile {
		return &v
	}).(IndexerClusterSpecVolumesAzureFilePtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesAzureFileOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureFile) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// the name of secret that contains Azure Storage Account Name and Key
func (o IndexerClusterSpecVolumesAzureFileOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureFile) string { return v.SecretName }).(pulumi.StringOutput)
}

// Share Name
func (o IndexerClusterSpecVolumesAzureFileOutput) ShareName() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesAzureFile) string { return v.ShareName }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesAzureFilePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesAzureFilePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesAzureFile)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesAzureFilePtrOutput) ToIndexerClusterSpecVolumesAzureFilePtrOutput() IndexerClusterSpecVolumesAzureFilePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureFilePtrOutput) ToIndexerClusterSpecVolumesAzureFilePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesAzureFilePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesAzureFilePtrOutput) Elem() IndexerClusterSpecVolumesAzureFileOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureFile) IndexerClusterSpecVolumesAzureFile { return *v }).(IndexerClusterSpecVolumesAzureFileOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesAzureFilePtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureFile) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// the name of secret that contains Azure Storage Account Name and Key
func (o IndexerClusterSpecVolumesAzureFilePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureFile) *string {
		if v == nil {
			return nil
		}
		return &v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Share Name
func (o IndexerClusterSpecVolumesAzureFilePtrOutput) ShareName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesAzureFile) *string {
		if v == nil {
			return nil
		}
		return &v.ShareName
	}).(pulumi.StringPtrOutput)
}

// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesCephfs struct {
	// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	Monitors []string `pulumi:"monitors"`
	// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
	Path *string `pulumi:"path"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	ReadOnly *bool `pulumi:"readOnly"`
	// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretFile *string `pulumi:"secretFile"`
	// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretRef *IndexerClusterSpecVolumesCephfsSecretRef `pulumi:"secretRef"`
	// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	User *string `pulumi:"user"`
}

// IndexerClusterSpecVolumesCephfsInput is an input type that accepts IndexerClusterSpecVolumesCephfsArgs and IndexerClusterSpecVolumesCephfsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCephfsInput` via:
//
//          IndexerClusterSpecVolumesCephfsArgs{...}
type IndexerClusterSpecVolumesCephfsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCephfsOutput() IndexerClusterSpecVolumesCephfsOutput
	ToIndexerClusterSpecVolumesCephfsOutputWithContext(context.Context) IndexerClusterSpecVolumesCephfsOutput
}

// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesCephfsArgs struct {
	// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	Monitors pulumi.StringArrayInput `pulumi:"monitors"`
	// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretFile pulumi.StringPtrInput `pulumi:"secretFile"`
	// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	SecretRef IndexerClusterSpecVolumesCephfsSecretRefPtrInput `pulumi:"secretRef"`
	// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	User pulumi.StringPtrInput `pulumi:"user"`
}

func (IndexerClusterSpecVolumesCephfsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCephfs)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCephfsArgs) ToIndexerClusterSpecVolumesCephfsOutput() IndexerClusterSpecVolumesCephfsOutput {
	return i.ToIndexerClusterSpecVolumesCephfsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCephfsArgs) ToIndexerClusterSpecVolumesCephfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsOutput)
}

func (i IndexerClusterSpecVolumesCephfsArgs) ToIndexerClusterSpecVolumesCephfsPtrOutput() IndexerClusterSpecVolumesCephfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCephfsArgs) ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsOutput).ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCephfsPtrInput is an input type that accepts IndexerClusterSpecVolumesCephfsArgs, IndexerClusterSpecVolumesCephfsPtr and IndexerClusterSpecVolumesCephfsPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCephfsPtrInput` via:
//
//          IndexerClusterSpecVolumesCephfsArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCephfsPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCephfsPtrOutput() IndexerClusterSpecVolumesCephfsPtrOutput
	ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCephfsPtrOutput
}

type indexerClusterSpecVolumesCephfsPtrType IndexerClusterSpecVolumesCephfsArgs

func IndexerClusterSpecVolumesCephfsPtr(v *IndexerClusterSpecVolumesCephfsArgs) IndexerClusterSpecVolumesCephfsPtrInput {
	return (*indexerClusterSpecVolumesCephfsPtrType)(v)
}

func (*indexerClusterSpecVolumesCephfsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCephfs)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCephfsPtrType) ToIndexerClusterSpecVolumesCephfsPtrOutput() IndexerClusterSpecVolumesCephfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCephfsPtrType) ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsPtrOutput)
}

// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesCephfsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCephfsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCephfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCephfsOutput) ToIndexerClusterSpecVolumesCephfsOutput() IndexerClusterSpecVolumesCephfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsOutput) ToIndexerClusterSpecVolumesCephfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsOutput) ToIndexerClusterSpecVolumesCephfsPtrOutput() IndexerClusterSpecVolumesCephfsPtrOutput {
	return o.ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCephfsOutput) ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *IndexerClusterSpecVolumesCephfs {
		return &v
	}).(IndexerClusterSpecVolumesCephfsPtrOutput)
}

// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsOutput) Monitors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) []string { return v.Monitors }).(pulumi.StringArrayOutput)
}

// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
func (o IndexerClusterSpecVolumesCephfsOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsOutput) SecretFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *string { return v.SecretFile }).(pulumi.StringPtrOutput)
}

// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsOutput) SecretRef() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *IndexerClusterSpecVolumesCephfsSecretRef { return v.SecretRef }).(IndexerClusterSpecVolumesCephfsSecretRefPtrOutput)
}

// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfs) *string { return v.User }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesCephfsPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCephfsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCephfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCephfsPtrOutput) ToIndexerClusterSpecVolumesCephfsPtrOutput() IndexerClusterSpecVolumesCephfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsPtrOutput) ToIndexerClusterSpecVolumesCephfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsPtrOutput) Elem() IndexerClusterSpecVolumesCephfsOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) IndexerClusterSpecVolumesCephfs { return *v }).(IndexerClusterSpecVolumesCephfsOutput)
}

// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsPtrOutput) Monitors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) []string {
		if v == nil {
			return nil
		}
		return v.Monitors
	}).(pulumi.StringArrayOutput)
}

// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
func (o IndexerClusterSpecVolumesCephfsPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsPtrOutput) SecretFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) *string {
		if v == nil {
			return nil
		}
		return v.SecretFile
	}).(pulumi.StringPtrOutput)
}

// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsPtrOutput) SecretRef() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) *IndexerClusterSpecVolumesCephfsSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesCephfsSecretRefPtrOutput)
}

// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesCephfsPtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfs) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
type IndexerClusterSpecVolumesCephfsSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesCephfsSecretRefInput is an input type that accepts IndexerClusterSpecVolumesCephfsSecretRefArgs and IndexerClusterSpecVolumesCephfsSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCephfsSecretRefInput` via:
//
//          IndexerClusterSpecVolumesCephfsSecretRefArgs{...}
type IndexerClusterSpecVolumesCephfsSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCephfsSecretRefOutput() IndexerClusterSpecVolumesCephfsSecretRefOutput
	ToIndexerClusterSpecVolumesCephfsSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesCephfsSecretRefOutput
}

// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
type IndexerClusterSpecVolumesCephfsSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesCephfsSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCephfsSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCephfsSecretRefArgs) ToIndexerClusterSpecVolumesCephfsSecretRefOutput() IndexerClusterSpecVolumesCephfsSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesCephfsSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCephfsSecretRefArgs) ToIndexerClusterSpecVolumesCephfsSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsSecretRefOutput)
}

func (i IndexerClusterSpecVolumesCephfsSecretRefArgs) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutput() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCephfsSecretRefArgs) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsSecretRefOutput).ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCephfsSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesCephfsSecretRefArgs, IndexerClusterSpecVolumesCephfsSecretRefPtr and IndexerClusterSpecVolumesCephfsSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCephfsSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesCephfsSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCephfsSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutput() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput
	ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCephfsSecretRefPtrOutput
}

type indexerClusterSpecVolumesCephfsSecretRefPtrType IndexerClusterSpecVolumesCephfsSecretRefArgs

func IndexerClusterSpecVolumesCephfsSecretRefPtr(v *IndexerClusterSpecVolumesCephfsSecretRefArgs) IndexerClusterSpecVolumesCephfsSecretRefPtrInput {
	return (*indexerClusterSpecVolumesCephfsSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesCephfsSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCephfsSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCephfsSecretRefPtrType) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutput() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCephfsSecretRefPtrType) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCephfsSecretRefPtrOutput)
}

// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
type IndexerClusterSpecVolumesCephfsSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCephfsSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCephfsSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCephfsSecretRefOutput) ToIndexerClusterSpecVolumesCephfsSecretRefOutput() IndexerClusterSpecVolumesCephfsSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsSecretRefOutput) ToIndexerClusterSpecVolumesCephfsSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsSecretRefOutput) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutput() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCephfsSecretRefOutput) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfsSecretRef) *IndexerClusterSpecVolumesCephfsSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesCephfsSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCephfsSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCephfsSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesCephfsSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCephfsSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCephfsSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCephfsSecretRefPtrOutput) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutput() IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsSecretRefPtrOutput) ToIndexerClusterSpecVolumesCephfsSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCephfsSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCephfsSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesCephfsSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfsSecretRef) IndexerClusterSpecVolumesCephfsSecretRef { return *v }).(IndexerClusterSpecVolumesCephfsSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCephfsSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCephfsSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
type IndexerClusterSpecVolumesCinder struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	FsType *string `pulumi:"fsType"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	ReadOnly *bool `pulumi:"readOnly"`
	// Optional: points to a secret object containing parameters used to connect to OpenStack.
	SecretRef *IndexerClusterSpecVolumesCinderSecretRef `pulumi:"secretRef"`
	// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	VolumeID string `pulumi:"volumeID"`
}

// IndexerClusterSpecVolumesCinderInput is an input type that accepts IndexerClusterSpecVolumesCinderArgs and IndexerClusterSpecVolumesCinderOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCinderInput` via:
//
//          IndexerClusterSpecVolumesCinderArgs{...}
type IndexerClusterSpecVolumesCinderInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCinderOutput() IndexerClusterSpecVolumesCinderOutput
	ToIndexerClusterSpecVolumesCinderOutputWithContext(context.Context) IndexerClusterSpecVolumesCinderOutput
}

// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
type IndexerClusterSpecVolumesCinderArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Optional: points to a secret object containing parameters used to connect to OpenStack.
	SecretRef IndexerClusterSpecVolumesCinderSecretRefPtrInput `pulumi:"secretRef"`
	// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	VolumeID pulumi.StringInput `pulumi:"volumeID"`
}

func (IndexerClusterSpecVolumesCinderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCinder)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCinderArgs) ToIndexerClusterSpecVolumesCinderOutput() IndexerClusterSpecVolumesCinderOutput {
	return i.ToIndexerClusterSpecVolumesCinderOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCinderArgs) ToIndexerClusterSpecVolumesCinderOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderOutput)
}

func (i IndexerClusterSpecVolumesCinderArgs) ToIndexerClusterSpecVolumesCinderPtrOutput() IndexerClusterSpecVolumesCinderPtrOutput {
	return i.ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCinderArgs) ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderOutput).ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCinderPtrInput is an input type that accepts IndexerClusterSpecVolumesCinderArgs, IndexerClusterSpecVolumesCinderPtr and IndexerClusterSpecVolumesCinderPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCinderPtrInput` via:
//
//          IndexerClusterSpecVolumesCinderArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCinderPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCinderPtrOutput() IndexerClusterSpecVolumesCinderPtrOutput
	ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCinderPtrOutput
}

type indexerClusterSpecVolumesCinderPtrType IndexerClusterSpecVolumesCinderArgs

func IndexerClusterSpecVolumesCinderPtr(v *IndexerClusterSpecVolumesCinderArgs) IndexerClusterSpecVolumesCinderPtrInput {
	return (*indexerClusterSpecVolumesCinderPtrType)(v)
}

func (*indexerClusterSpecVolumesCinderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCinder)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCinderPtrType) ToIndexerClusterSpecVolumesCinderPtrOutput() IndexerClusterSpecVolumesCinderPtrOutput {
	return i.ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCinderPtrType) ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderPtrOutput)
}

// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
type IndexerClusterSpecVolumesCinderOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCinderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCinder)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCinderOutput) ToIndexerClusterSpecVolumesCinderOutput() IndexerClusterSpecVolumesCinderOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderOutput) ToIndexerClusterSpecVolumesCinderOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderOutput) ToIndexerClusterSpecVolumesCinderPtrOutput() IndexerClusterSpecVolumesCinderPtrOutput {
	return o.ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCinderOutput) ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinder) *IndexerClusterSpecVolumesCinder {
		return &v
	}).(IndexerClusterSpecVolumesCinderPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinder) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinder) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Optional: points to a secret object containing parameters used to connect to OpenStack.
func (o IndexerClusterSpecVolumesCinderOutput) SecretRef() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinder) *IndexerClusterSpecVolumesCinderSecretRef { return v.SecretRef }).(IndexerClusterSpecVolumesCinderSecretRefPtrOutput)
}

// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderOutput) VolumeID() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinder) string { return v.VolumeID }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesCinderPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCinderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCinder)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCinderPtrOutput) ToIndexerClusterSpecVolumesCinderPtrOutput() IndexerClusterSpecVolumesCinderPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderPtrOutput) ToIndexerClusterSpecVolumesCinderPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderPtrOutput) Elem() IndexerClusterSpecVolumesCinderOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinder) IndexerClusterSpecVolumesCinder { return *v }).(IndexerClusterSpecVolumesCinderOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinder) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinder) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Optional: points to a secret object containing parameters used to connect to OpenStack.
func (o IndexerClusterSpecVolumesCinderPtrOutput) SecretRef() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinder) *IndexerClusterSpecVolumesCinderSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesCinderSecretRefPtrOutput)
}

// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
func (o IndexerClusterSpecVolumesCinderPtrOutput) VolumeID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinder) *string {
		if v == nil {
			return nil
		}
		return &v.VolumeID
	}).(pulumi.StringPtrOutput)
}

// Optional: points to a secret object containing parameters used to connect to OpenStack.
type IndexerClusterSpecVolumesCinderSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesCinderSecretRefInput is an input type that accepts IndexerClusterSpecVolumesCinderSecretRefArgs and IndexerClusterSpecVolumesCinderSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCinderSecretRefInput` via:
//
//          IndexerClusterSpecVolumesCinderSecretRefArgs{...}
type IndexerClusterSpecVolumesCinderSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCinderSecretRefOutput() IndexerClusterSpecVolumesCinderSecretRefOutput
	ToIndexerClusterSpecVolumesCinderSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesCinderSecretRefOutput
}

// Optional: points to a secret object containing parameters used to connect to OpenStack.
type IndexerClusterSpecVolumesCinderSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesCinderSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCinderSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCinderSecretRefArgs) ToIndexerClusterSpecVolumesCinderSecretRefOutput() IndexerClusterSpecVolumesCinderSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesCinderSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCinderSecretRefArgs) ToIndexerClusterSpecVolumesCinderSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderSecretRefOutput)
}

func (i IndexerClusterSpecVolumesCinderSecretRefArgs) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutput() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCinderSecretRefArgs) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderSecretRefOutput).ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCinderSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesCinderSecretRefArgs, IndexerClusterSpecVolumesCinderSecretRefPtr and IndexerClusterSpecVolumesCinderSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCinderSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesCinderSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCinderSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCinderSecretRefPtrOutput() IndexerClusterSpecVolumesCinderSecretRefPtrOutput
	ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCinderSecretRefPtrOutput
}

type indexerClusterSpecVolumesCinderSecretRefPtrType IndexerClusterSpecVolumesCinderSecretRefArgs

func IndexerClusterSpecVolumesCinderSecretRefPtr(v *IndexerClusterSpecVolumesCinderSecretRefArgs) IndexerClusterSpecVolumesCinderSecretRefPtrInput {
	return (*indexerClusterSpecVolumesCinderSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesCinderSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCinderSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCinderSecretRefPtrType) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutput() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCinderSecretRefPtrType) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCinderSecretRefPtrOutput)
}

// Optional: points to a secret object containing parameters used to connect to OpenStack.
type IndexerClusterSpecVolumesCinderSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCinderSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCinderSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCinderSecretRefOutput) ToIndexerClusterSpecVolumesCinderSecretRefOutput() IndexerClusterSpecVolumesCinderSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderSecretRefOutput) ToIndexerClusterSpecVolumesCinderSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderSecretRefOutput) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutput() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCinderSecretRefOutput) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinderSecretRef) *IndexerClusterSpecVolumesCinderSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesCinderSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCinderSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCinderSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesCinderSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCinderSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCinderSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCinderSecretRefPtrOutput) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutput() IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderSecretRefPtrOutput) ToIndexerClusterSpecVolumesCinderSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCinderSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCinderSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesCinderSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinderSecretRef) IndexerClusterSpecVolumesCinderSecretRef { return *v }).(IndexerClusterSpecVolumesCinderSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCinderSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCinderSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ConfigMap represents a configMap that should populate this volume
type IndexerClusterSpecVolumesConfigMap struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []IndexerClusterSpecVolumesConfigMapItems `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
	// Specify whether the ConfigMap or its keys must be defined
	Optional *bool `pulumi:"optional"`
}

// IndexerClusterSpecVolumesConfigMapInput is an input type that accepts IndexerClusterSpecVolumesConfigMap and IndexerClusterSpecVolumesConfigMapOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesConfigMapInput` via:
//
//          IndexerClusterSpecVolumesConfigMap{ "key": IndexerClusterSpecVolumesConfigArgs{...} }
type IndexerClusterSpecVolumesConfigMapInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesConfigMapOutput() IndexerClusterSpecVolumesConfigMapOutput
	ToIndexerClusterSpecVolumesConfigMapOutputWithContext(context.Context) IndexerClusterSpecVolumesConfigMapOutput
}

// ConfigMap represents a configMap that should populate this volume
type IndexerClusterSpecVolumesConfigMapArgs struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items IndexerClusterSpecVolumesConfigMapItemsArrayInput `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specify whether the ConfigMap or its keys must be defined
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (IndexerClusterSpecVolumesConfigMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesConfigMap)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesConfigMapArgs) ToIndexerClusterSpecVolumesConfigMapOutput() IndexerClusterSpecVolumesConfigMapOutput {
	return i.ToIndexerClusterSpecVolumesConfigMapOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesConfigMapArgs) ToIndexerClusterSpecVolumesConfigMapOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesConfigMapOutput)
}

func (i IndexerClusterSpecVolumesConfigMapArgs) ToIndexerClusterSpecVolumesConfigMapPtrOutput() IndexerClusterSpecVolumesConfigMapPtrOutput {
	return i.ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesConfigMapArgs) ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesConfigMapOutput).ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesConfigMapPtrInput is an input type that accepts IndexerClusterSpecVolumesConfigMapArgs, IndexerClusterSpecVolumesConfigMapPtr and IndexerClusterSpecVolumesConfigMapPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesConfigMapPtrInput` via:
//
//          IndexerClusterSpecVolumesConfigMapArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesConfigMapPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesConfigMapPtrOutput() IndexerClusterSpecVolumesConfigMapPtrOutput
	ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesConfigMapPtrOutput
}

type indexerClusterSpecVolumesConfigMapPtrType IndexerClusterSpecVolumesConfigMapArgs

func IndexerClusterSpecVolumesConfigMapPtr(v *IndexerClusterSpecVolumesConfigMapArgs) IndexerClusterSpecVolumesConfigMapPtrInput {
	return (*indexerClusterSpecVolumesConfigMapPtrType)(v)
}

func (*indexerClusterSpecVolumesConfigMapPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesConfigMap)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesConfigMapPtrType) ToIndexerClusterSpecVolumesConfigMapPtrOutput() IndexerClusterSpecVolumesConfigMapPtrOutput {
	return i.ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesConfigMapPtrType) ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesConfigMapPtrOutput)
}

// ConfigMap represents a configMap that should populate this volume
type IndexerClusterSpecVolumesConfigMapOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesConfigMap)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesConfigMapOutput) ToIndexerClusterSpecVolumesConfigMapOutput() IndexerClusterSpecVolumesConfigMapOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapOutput) ToIndexerClusterSpecVolumesConfigMapOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapOutput) ToIndexerClusterSpecVolumesConfigMapPtrOutput() IndexerClusterSpecVolumesConfigMapPtrOutput {
	return o.ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesConfigMapOutput) ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMap) *IndexerClusterSpecVolumesConfigMap {
		return &v
	}).(IndexerClusterSpecVolumesConfigMapPtrOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesConfigMapOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMap) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesConfigMapOutput) Items() IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMap) []IndexerClusterSpecVolumesConfigMapItems { return v.Items }).(IndexerClusterSpecVolumesConfigMapItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesConfigMapOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMap) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specify whether the ConfigMap or its keys must be defined
func (o IndexerClusterSpecVolumesConfigMapOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMap) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesConfigMapPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesConfigMapPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesConfigMap)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesConfigMapPtrOutput) ToIndexerClusterSpecVolumesConfigMapPtrOutput() IndexerClusterSpecVolumesConfigMapPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapPtrOutput) ToIndexerClusterSpecVolumesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapPtrOutput) Elem() IndexerClusterSpecVolumesConfigMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesConfigMap) IndexerClusterSpecVolumesConfigMap { return *v }).(IndexerClusterSpecVolumesConfigMapOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesConfigMapPtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesConfigMap) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesConfigMapPtrOutput) Items() IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesConfigMap) []IndexerClusterSpecVolumesConfigMapItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesConfigMapItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesConfigMapPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesConfigMap) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specify whether the ConfigMap or its keys must be defined
func (o IndexerClusterSpecVolumesConfigMapPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesConfigMap) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesConfigMapItems struct {
	// The key to project.
	Key string `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path string `pulumi:"path"`
}

// IndexerClusterSpecVolumesConfigMapItemsInput is an input type that accepts IndexerClusterSpecVolumesConfigMapItemsArgs and IndexerClusterSpecVolumesConfigMapItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesConfigMapItemsInput` via:
//
//          IndexerClusterSpecVolumesConfigMapItemsArgs{...}
type IndexerClusterSpecVolumesConfigMapItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesConfigMapItemsOutput() IndexerClusterSpecVolumesConfigMapItemsOutput
	ToIndexerClusterSpecVolumesConfigMapItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesConfigMapItemsOutput
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesConfigMapItemsArgs struct {
	// The key to project.
	Key pulumi.StringInput `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IndexerClusterSpecVolumesConfigMapItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesConfigMapItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesConfigMapItemsArgs) ToIndexerClusterSpecVolumesConfigMapItemsOutput() IndexerClusterSpecVolumesConfigMapItemsOutput {
	return i.ToIndexerClusterSpecVolumesConfigMapItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesConfigMapItemsArgs) ToIndexerClusterSpecVolumesConfigMapItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesConfigMapItemsOutput)
}

// IndexerClusterSpecVolumesConfigMapItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesConfigMapItemsArray and IndexerClusterSpecVolumesConfigMapItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesConfigMapItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesConfigMapItemsArray{ IndexerClusterSpecVolumesConfigMapItemsArgs{...} }
type IndexerClusterSpecVolumesConfigMapItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesConfigMapItemsArrayOutput
	ToIndexerClusterSpecVolumesConfigMapItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesConfigMapItemsArrayOutput
}

type IndexerClusterSpecVolumesConfigMapItemsArray []IndexerClusterSpecVolumesConfigMapItemsInput

func (IndexerClusterSpecVolumesConfigMapItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesConfigMapItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesConfigMapItemsArray) ToIndexerClusterSpecVolumesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesConfigMapItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesConfigMapItemsArray) ToIndexerClusterSpecVolumesConfigMapItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesConfigMapItemsArrayOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesConfigMapItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesConfigMapItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesConfigMapItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesConfigMapItemsOutput) ToIndexerClusterSpecVolumesConfigMapItemsOutput() IndexerClusterSpecVolumesConfigMapItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapItemsOutput) ToIndexerClusterSpecVolumesConfigMapItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapItemsOutput {
	return o
}

// The key to project.
func (o IndexerClusterSpecVolumesConfigMapItemsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMapItems) string { return v.Key }).(pulumi.StringOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesConfigMapItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMapItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
func (o IndexerClusterSpecVolumesConfigMapItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesConfigMapItems) string { return v.Path }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesConfigMapItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesConfigMapItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesConfigMapItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesConfigMapItemsArrayOutput) ToIndexerClusterSpecVolumesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapItemsArrayOutput) ToIndexerClusterSpecVolumesConfigMapItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesConfigMapItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesConfigMapItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesConfigMapItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesConfigMapItems {
		return vs[0].([]IndexerClusterSpecVolumesConfigMapItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesConfigMapItemsOutput)
}

// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
type IndexerClusterSpecVolumesCsi struct {
	// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
	Driver string `pulumi:"driver"`
	// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
	FsType *string `pulumi:"fsType"`
	// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
	NodePublishSecretRef *IndexerClusterSpecVolumesCsiNodePublishSecretRef `pulumi:"nodePublishSecretRef"`
	// Specifies a read-only configuration for the volume. Defaults to false (read/write).
	ReadOnly *bool `pulumi:"readOnly"`
	// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
	VolumeAttributes map[string]string `pulumi:"volumeAttributes"`
}

// IndexerClusterSpecVolumesCsiInput is an input type that accepts IndexerClusterSpecVolumesCsiArgs and IndexerClusterSpecVolumesCsiOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCsiInput` via:
//
//          IndexerClusterSpecVolumesCsiArgs{...}
type IndexerClusterSpecVolumesCsiInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCsiOutput() IndexerClusterSpecVolumesCsiOutput
	ToIndexerClusterSpecVolumesCsiOutputWithContext(context.Context) IndexerClusterSpecVolumesCsiOutput
}

// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
type IndexerClusterSpecVolumesCsiArgs struct {
	// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
	Driver pulumi.StringInput `pulumi:"driver"`
	// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
	NodePublishSecretRef IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrInput `pulumi:"nodePublishSecretRef"`
	// Specifies a read-only configuration for the volume. Defaults to false (read/write).
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
	VolumeAttributes pulumi.StringMapInput `pulumi:"volumeAttributes"`
}

func (IndexerClusterSpecVolumesCsiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsi)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCsiArgs) ToIndexerClusterSpecVolumesCsiOutput() IndexerClusterSpecVolumesCsiOutput {
	return i.ToIndexerClusterSpecVolumesCsiOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCsiArgs) ToIndexerClusterSpecVolumesCsiOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiOutput)
}

func (i IndexerClusterSpecVolumesCsiArgs) ToIndexerClusterSpecVolumesCsiPtrOutput() IndexerClusterSpecVolumesCsiPtrOutput {
	return i.ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCsiArgs) ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiOutput).ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCsiPtrInput is an input type that accepts IndexerClusterSpecVolumesCsiArgs, IndexerClusterSpecVolumesCsiPtr and IndexerClusterSpecVolumesCsiPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCsiPtrInput` via:
//
//          IndexerClusterSpecVolumesCsiArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCsiPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCsiPtrOutput() IndexerClusterSpecVolumesCsiPtrOutput
	ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCsiPtrOutput
}

type indexerClusterSpecVolumesCsiPtrType IndexerClusterSpecVolumesCsiArgs

func IndexerClusterSpecVolumesCsiPtr(v *IndexerClusterSpecVolumesCsiArgs) IndexerClusterSpecVolumesCsiPtrInput {
	return (*indexerClusterSpecVolumesCsiPtrType)(v)
}

func (*indexerClusterSpecVolumesCsiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCsi)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCsiPtrType) ToIndexerClusterSpecVolumesCsiPtrOutput() IndexerClusterSpecVolumesCsiPtrOutput {
	return i.ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCsiPtrType) ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiPtrOutput)
}

// CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
type IndexerClusterSpecVolumesCsiOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCsiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsi)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCsiOutput) ToIndexerClusterSpecVolumesCsiOutput() IndexerClusterSpecVolumesCsiOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiOutput) ToIndexerClusterSpecVolumesCsiOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiOutput) ToIndexerClusterSpecVolumesCsiPtrOutput() IndexerClusterSpecVolumesCsiPtrOutput {
	return o.ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCsiOutput) ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) *IndexerClusterSpecVolumesCsi {
		return &v
	}).(IndexerClusterSpecVolumesCsiPtrOutput)
}

// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
func (o IndexerClusterSpecVolumesCsiOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) string { return v.Driver }).(pulumi.StringOutput)
}

// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
func (o IndexerClusterSpecVolumesCsiOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
func (o IndexerClusterSpecVolumesCsiOutput) NodePublishSecretRef() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) *IndexerClusterSpecVolumesCsiNodePublishSecretRef {
		return v.NodePublishSecretRef
	}).(IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput)
}

// Specifies a read-only configuration for the volume. Defaults to false (read/write).
func (o IndexerClusterSpecVolumesCsiOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
func (o IndexerClusterSpecVolumesCsiOutput) VolumeAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsi) map[string]string { return v.VolumeAttributes }).(pulumi.StringMapOutput)
}

type IndexerClusterSpecVolumesCsiPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCsiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCsi)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCsiPtrOutput) ToIndexerClusterSpecVolumesCsiPtrOutput() IndexerClusterSpecVolumesCsiPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiPtrOutput) ToIndexerClusterSpecVolumesCsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiPtrOutput) Elem() IndexerClusterSpecVolumesCsiOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) IndexerClusterSpecVolumesCsi { return *v }).(IndexerClusterSpecVolumesCsiOutput)
}

// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
func (o IndexerClusterSpecVolumesCsiPtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) *string {
		if v == nil {
			return nil
		}
		return &v.Driver
	}).(pulumi.StringPtrOutput)
}

// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
func (o IndexerClusterSpecVolumesCsiPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
func (o IndexerClusterSpecVolumesCsiPtrOutput) NodePublishSecretRef() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) *IndexerClusterSpecVolumesCsiNodePublishSecretRef {
		if v == nil {
			return nil
		}
		return v.NodePublishSecretRef
	}).(IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput)
}

// Specifies a read-only configuration for the volume. Defaults to false (read/write).
func (o IndexerClusterSpecVolumesCsiPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
func (o IndexerClusterSpecVolumesCsiPtrOutput) VolumeAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsi) map[string]string {
		if v == nil {
			return nil
		}
		return v.VolumeAttributes
	}).(pulumi.StringMapOutput)
}

// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
type IndexerClusterSpecVolumesCsiNodePublishSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesCsiNodePublishSecretRefInput is an input type that accepts IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs and IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCsiNodePublishSecretRefInput` via:
//
//          IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs{...}
type IndexerClusterSpecVolumesCsiNodePublishSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput
	ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput
}

// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
type IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsiNodePublishSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput)
}

func (i IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput).ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs, IndexerClusterSpecVolumesCsiNodePublishSecretRefPtr and IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput
	ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput
}

type indexerClusterSpecVolumesCsiNodePublishSecretRefPtrType IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs

func IndexerClusterSpecVolumesCsiNodePublishSecretRefPtr(v *IndexerClusterSpecVolumesCsiNodePublishSecretRefArgs) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrInput {
	return (*indexerClusterSpecVolumesCsiNodePublishSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesCsiNodePublishSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCsiNodePublishSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesCsiNodePublishSecretRefPtrType) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesCsiNodePublishSecretRefPtrType) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput)
}

// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
type IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsiNodePublishSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsiNodePublishSecretRef) *IndexerClusterSpecVolumesCsiNodePublishSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesCsiNodePublishSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesCsiNodePublishSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput() IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput) ToIndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsiNodePublishSecretRef) IndexerClusterSpecVolumesCsiNodePublishSecretRef {
		return *v
	}).(IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesCsiNodePublishSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
type IndexerClusterSpecVolumesCsiVolumeAttributes struct {
}

// IndexerClusterSpecVolumesCsiVolumeAttributesInput is an input type that accepts IndexerClusterSpecVolumesCsiVolumeAttributesArgs and IndexerClusterSpecVolumesCsiVolumeAttributesOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesCsiVolumeAttributesInput` via:
//
//          IndexerClusterSpecVolumesCsiVolumeAttributesArgs{...}
type IndexerClusterSpecVolumesCsiVolumeAttributesInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesCsiVolumeAttributesOutput() IndexerClusterSpecVolumesCsiVolumeAttributesOutput
	ToIndexerClusterSpecVolumesCsiVolumeAttributesOutputWithContext(context.Context) IndexerClusterSpecVolumesCsiVolumeAttributesOutput
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
type IndexerClusterSpecVolumesCsiVolumeAttributesArgs struct {
}

func (IndexerClusterSpecVolumesCsiVolumeAttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsiVolumeAttributes)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesCsiVolumeAttributesArgs) ToIndexerClusterSpecVolumesCsiVolumeAttributesOutput() IndexerClusterSpecVolumesCsiVolumeAttributesOutput {
	return i.ToIndexerClusterSpecVolumesCsiVolumeAttributesOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesCsiVolumeAttributesArgs) ToIndexerClusterSpecVolumesCsiVolumeAttributesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiVolumeAttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesCsiVolumeAttributesOutput)
}

// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
type IndexerClusterSpecVolumesCsiVolumeAttributesOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesCsiVolumeAttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesCsiVolumeAttributes)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesCsiVolumeAttributesOutput) ToIndexerClusterSpecVolumesCsiVolumeAttributesOutput() IndexerClusterSpecVolumesCsiVolumeAttributesOutput {
	return o
}

func (o IndexerClusterSpecVolumesCsiVolumeAttributesOutput) ToIndexerClusterSpecVolumesCsiVolumeAttributesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesCsiVolumeAttributesOutput {
	return o
}

// DownwardAPI represents downward API about the pod that should populate this volume
type IndexerClusterSpecVolumesDownwardAPI struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// Items is a list of downward API volume file
	Items []IndexerClusterSpecVolumesDownwardAPIItems `pulumi:"items"`
}

// IndexerClusterSpecVolumesDownwardAPIInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIArgs and IndexerClusterSpecVolumesDownwardAPIOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIArgs{...}
type IndexerClusterSpecVolumesDownwardAPIInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIOutput() IndexerClusterSpecVolumesDownwardAPIOutput
	ToIndexerClusterSpecVolumesDownwardAPIOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIOutput
}

// DownwardAPI represents downward API about the pod that should populate this volume
type IndexerClusterSpecVolumesDownwardAPIArgs struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// Items is a list of downward API volume file
	Items IndexerClusterSpecVolumesDownwardAPIItemsArrayInput `pulumi:"items"`
}

func (IndexerClusterSpecVolumesDownwardAPIArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPI)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesDownwardAPIArgs) ToIndexerClusterSpecVolumesDownwardAPIOutput() IndexerClusterSpecVolumesDownwardAPIOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIArgs) ToIndexerClusterSpecVolumesDownwardAPIOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIOutput)
}

func (i IndexerClusterSpecVolumesDownwardAPIArgs) ToIndexerClusterSpecVolumesDownwardAPIPtrOutput() IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIArgs) ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIOutput).ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesDownwardAPIPtrInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIArgs, IndexerClusterSpecVolumesDownwardAPIPtr and IndexerClusterSpecVolumesDownwardAPIPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIPtrInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesDownwardAPIPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIPtrOutput() IndexerClusterSpecVolumesDownwardAPIPtrOutput
	ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIPtrOutput
}

type indexerClusterSpecVolumesDownwardAPIPtrType IndexerClusterSpecVolumesDownwardAPIArgs

func IndexerClusterSpecVolumesDownwardAPIPtr(v *IndexerClusterSpecVolumesDownwardAPIArgs) IndexerClusterSpecVolumesDownwardAPIPtrInput {
	return (*indexerClusterSpecVolumesDownwardAPIPtrType)(v)
}

func (*indexerClusterSpecVolumesDownwardAPIPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPI)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesDownwardAPIPtrType) ToIndexerClusterSpecVolumesDownwardAPIPtrOutput() IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesDownwardAPIPtrType) ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIPtrOutput)
}

// DownwardAPI represents downward API about the pod that should populate this volume
type IndexerClusterSpecVolumesDownwardAPIOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPI)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIOutput) ToIndexerClusterSpecVolumesDownwardAPIOutput() IndexerClusterSpecVolumesDownwardAPIOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIOutput) ToIndexerClusterSpecVolumesDownwardAPIOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIOutput) ToIndexerClusterSpecVolumesDownwardAPIPtrOutput() IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return o.ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesDownwardAPIOutput) ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPI) *IndexerClusterSpecVolumesDownwardAPI {
		return &v
	}).(IndexerClusterSpecVolumesDownwardAPIPtrOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesDownwardAPIOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPI) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// Items is a list of downward API volume file
func (o IndexerClusterSpecVolumesDownwardAPIOutput) Items() IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPI) []IndexerClusterSpecVolumesDownwardAPIItems {
		return v.Items
	}).(IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput)
}

type IndexerClusterSpecVolumesDownwardAPIPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPI)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIPtrOutput() IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIPtrOutput) Elem() IndexerClusterSpecVolumesDownwardAPIOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPI) IndexerClusterSpecVolumesDownwardAPI { return *v }).(IndexerClusterSpecVolumesDownwardAPIOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesDownwardAPIPtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPI) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// Items is a list of downward API volume file
func (o IndexerClusterSpecVolumesDownwardAPIPtrOutput) Items() IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPI) []IndexerClusterSpecVolumesDownwardAPIItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput)
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesDownwardAPIItems struct {
	// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
	FieldRef *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef `pulumi:"fieldRef"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
	Path string `pulumi:"path"`
	// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
	ResourceFieldRef *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef `pulumi:"resourceFieldRef"`
}

// IndexerClusterSpecVolumesDownwardAPIItemsInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsArgs and IndexerClusterSpecVolumesDownwardAPIItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsArgs{...}
type IndexerClusterSpecVolumesDownwardAPIItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsOutput() IndexerClusterSpecVolumesDownwardAPIItemsOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsOutput
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesDownwardAPIItemsArgs struct {
	// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
	FieldRef IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrInput `pulumi:"fieldRef"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
	Path pulumi.StringInput `pulumi:"path"`
	// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
	ResourceFieldRef IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrInput `pulumi:"resourceFieldRef"`
}

func (IndexerClusterSpecVolumesDownwardAPIItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsOutput() IndexerClusterSpecVolumesDownwardAPIItemsOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsOutput)
}

// IndexerClusterSpecVolumesDownwardAPIItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsArray and IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsArray{ IndexerClusterSpecVolumesDownwardAPIItemsArgs{...} }
type IndexerClusterSpecVolumesDownwardAPIItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput
}

type IndexerClusterSpecVolumesDownwardAPIItemsArray []IndexerClusterSpecVolumesDownwardAPIItemsInput

func (IndexerClusterSpecVolumesDownwardAPIItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesDownwardAPIItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsArray) ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsArray) ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput)
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesDownwardAPIItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsOutput() IndexerClusterSpecVolumesDownwardAPIItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsOutput {
	return o
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) FieldRef() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItems) *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef {
		return v.FieldRef
	}).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItems) string { return v.Path }).(pulumi.StringOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
func (o IndexerClusterSpecVolumesDownwardAPIItemsOutput) ResourceFieldRef() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItems) *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef {
		return v.ResourceFieldRef
	}).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput)
}

type IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesDownwardAPIItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesDownwardAPIItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesDownwardAPIItems {
		return vs[0].([]IndexerClusterSpecVolumesDownwardAPIItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesDownwardAPIItemsOutput)
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesDownwardAPIItemsFieldRef struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion *string `pulumi:"apiVersion"`
	// Path of the field to select in the specified API version.
	FieldPath string `pulumi:"fieldPath"`
}

// IndexerClusterSpecVolumesDownwardAPIItemsFieldRefInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs and IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsFieldRefInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs{...}
type IndexerClusterSpecVolumesDownwardAPIItemsFieldRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Path of the field to select in the specified API version.
	FieldPath pulumi.StringInput `pulumi:"fieldPath"`
}

func (IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput)
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput).ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs, IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtr and IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput
}

type indexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrType IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs

func IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtr(v *IndexerClusterSpecVolumesDownwardAPIItemsFieldRefArgs) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrInput {
	return (*indexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrType)(v)
}

func (*indexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrType) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrType) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput)
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef {
		return &v
	}).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput)
}

// Version of the schema the FieldPath is written in terms of, defaults to "v1".
func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Path of the field to select in the specified API version.
func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput) FieldPath() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) string { return v.FieldPath }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) Elem() IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) IndexerClusterSpecVolumesDownwardAPIItemsFieldRef {
		return *v
	}).(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput)
}

// Version of the schema the FieldPath is written in terms of, defaults to "v1".
func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// Path of the field to select in the specified API version.
func (o IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsFieldRef) *string {
		if v == nil {
			return nil
		}
		return &v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef struct {
	// Container name: required for volumes, optional for env vars
	ContainerName *string `pulumi:"containerName"`
	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor *string `pulumi:"divisor"`
	// Required: resource to select
	Resource string `pulumi:"resource"`
}

// IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs and IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs{...}
type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs struct {
	// Container name: required for volumes, optional for env vars
	ContainerName pulumi.StringPtrInput `pulumi:"containerName"`
	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor pulumi.StringPtrInput `pulumi:"divisor"`
	// Required: resource to select
	Resource pulumi.StringInput `pulumi:"resource"`
}

func (IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput)
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput).ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrInput is an input type that accepts IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs, IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtr and IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrInput` via:
//
//          IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput
	ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput
}

type indexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrType IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs

func IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtr(v *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefArgs) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrInput {
	return (*indexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrType)(v)
}

func (*indexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrType) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrType) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef {
		return &v
	}).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput)
}

// Container name: required for volumes, optional for env vars
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) ContainerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *string { return v.ContainerName }).(pulumi.StringPtrOutput)
}

// Specifies the output format of the exposed resources, defaults to "1"
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) Divisor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *string { return v.Divisor }).(pulumi.StringPtrOutput)
}

// Required: resource to select
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput) Resource() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) string { return v.Resource }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) ToIndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) Elem() IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef {
		return *v
	}).(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput)
}

// Container name: required for volumes, optional for env vars
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) ContainerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.ContainerName
	}).(pulumi.StringPtrOutput)
}

// Specifies the output format of the exposed resources, defaults to "1"
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) Divisor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.Divisor
	}).(pulumi.StringPtrOutput)
}

// Required: resource to select
func (o IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput) Resource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return &v.Resource
	}).(pulumi.StringPtrOutput)
}

// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
type IndexerClusterSpecVolumesEmptyDir struct {
	// What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	Medium *string `pulumi:"medium"`
	// Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
	SizeLimit *string `pulumi:"sizeLimit"`
}

// IndexerClusterSpecVolumesEmptyDirInput is an input type that accepts IndexerClusterSpecVolumesEmptyDirArgs and IndexerClusterSpecVolumesEmptyDirOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesEmptyDirInput` via:
//
//          IndexerClusterSpecVolumesEmptyDirArgs{...}
type IndexerClusterSpecVolumesEmptyDirInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesEmptyDirOutput() IndexerClusterSpecVolumesEmptyDirOutput
	ToIndexerClusterSpecVolumesEmptyDirOutputWithContext(context.Context) IndexerClusterSpecVolumesEmptyDirOutput
}

// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
type IndexerClusterSpecVolumesEmptyDirArgs struct {
	// What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	Medium pulumi.StringPtrInput `pulumi:"medium"`
	// Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
	SizeLimit pulumi.StringPtrInput `pulumi:"sizeLimit"`
}

func (IndexerClusterSpecVolumesEmptyDirArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesEmptyDir)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesEmptyDirArgs) ToIndexerClusterSpecVolumesEmptyDirOutput() IndexerClusterSpecVolumesEmptyDirOutput {
	return i.ToIndexerClusterSpecVolumesEmptyDirOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesEmptyDirArgs) ToIndexerClusterSpecVolumesEmptyDirOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesEmptyDirOutput)
}

func (i IndexerClusterSpecVolumesEmptyDirArgs) ToIndexerClusterSpecVolumesEmptyDirPtrOutput() IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return i.ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesEmptyDirArgs) ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesEmptyDirOutput).ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesEmptyDirPtrInput is an input type that accepts IndexerClusterSpecVolumesEmptyDirArgs, IndexerClusterSpecVolumesEmptyDirPtr and IndexerClusterSpecVolumesEmptyDirPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesEmptyDirPtrInput` via:
//
//          IndexerClusterSpecVolumesEmptyDirArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesEmptyDirPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesEmptyDirPtrOutput() IndexerClusterSpecVolumesEmptyDirPtrOutput
	ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesEmptyDirPtrOutput
}

type indexerClusterSpecVolumesEmptyDirPtrType IndexerClusterSpecVolumesEmptyDirArgs

func IndexerClusterSpecVolumesEmptyDirPtr(v *IndexerClusterSpecVolumesEmptyDirArgs) IndexerClusterSpecVolumesEmptyDirPtrInput {
	return (*indexerClusterSpecVolumesEmptyDirPtrType)(v)
}

func (*indexerClusterSpecVolumesEmptyDirPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesEmptyDir)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesEmptyDirPtrType) ToIndexerClusterSpecVolumesEmptyDirPtrOutput() IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return i.ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesEmptyDirPtrType) ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesEmptyDirPtrOutput)
}

// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
type IndexerClusterSpecVolumesEmptyDirOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesEmptyDirOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesEmptyDir)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesEmptyDirOutput) ToIndexerClusterSpecVolumesEmptyDirOutput() IndexerClusterSpecVolumesEmptyDirOutput {
	return o
}

func (o IndexerClusterSpecVolumesEmptyDirOutput) ToIndexerClusterSpecVolumesEmptyDirOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirOutput {
	return o
}

func (o IndexerClusterSpecVolumesEmptyDirOutput) ToIndexerClusterSpecVolumesEmptyDirPtrOutput() IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return o.ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesEmptyDirOutput) ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesEmptyDir) *IndexerClusterSpecVolumesEmptyDir {
		return &v
	}).(IndexerClusterSpecVolumesEmptyDirPtrOutput)
}

// What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
func (o IndexerClusterSpecVolumesEmptyDirOutput) Medium() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesEmptyDir) *string { return v.Medium }).(pulumi.StringPtrOutput)
}

// Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
func (o IndexerClusterSpecVolumesEmptyDirOutput) SizeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesEmptyDir) *string { return v.SizeLimit }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesEmptyDirPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesEmptyDirPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesEmptyDir)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesEmptyDirPtrOutput) ToIndexerClusterSpecVolumesEmptyDirPtrOutput() IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesEmptyDirPtrOutput) ToIndexerClusterSpecVolumesEmptyDirPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesEmptyDirPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesEmptyDirPtrOutput) Elem() IndexerClusterSpecVolumesEmptyDirOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesEmptyDir) IndexerClusterSpecVolumesEmptyDir { return *v }).(IndexerClusterSpecVolumesEmptyDirOutput)
}

// What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
func (o IndexerClusterSpecVolumesEmptyDirPtrOutput) Medium() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesEmptyDir) *string {
		if v == nil {
			return nil
		}
		return v.Medium
	}).(pulumi.StringPtrOutput)
}

// Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
func (o IndexerClusterSpecVolumesEmptyDirPtrOutput) SizeLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesEmptyDir) *string {
		if v == nil {
			return nil
		}
		return v.SizeLimit
	}).(pulumi.StringPtrOutput)
}

// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
type IndexerClusterSpecVolumesFc struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType *string `pulumi:"fsType"`
	// Optional: FC target lun number
	Lun *int `pulumi:"lun"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// Optional: FC target worldwide names (WWNs)
	TargetWWNs []string `pulumi:"targetWWNs"`
	// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
	Wwids []string `pulumi:"wwids"`
}

// IndexerClusterSpecVolumesFcInput is an input type that accepts IndexerClusterSpecVolumesFcArgs and IndexerClusterSpecVolumesFcOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFcInput` via:
//
//          IndexerClusterSpecVolumesFcArgs{...}
type IndexerClusterSpecVolumesFcInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFcOutput() IndexerClusterSpecVolumesFcOutput
	ToIndexerClusterSpecVolumesFcOutputWithContext(context.Context) IndexerClusterSpecVolumesFcOutput
}

// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
type IndexerClusterSpecVolumesFcArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Optional: FC target lun number
	Lun pulumi.IntPtrInput `pulumi:"lun"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Optional: FC target worldwide names (WWNs)
	TargetWWNs pulumi.StringArrayInput `pulumi:"targetWWNs"`
	// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
	Wwids pulumi.StringArrayInput `pulumi:"wwids"`
}

func (IndexerClusterSpecVolumesFcArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFc)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesFcArgs) ToIndexerClusterSpecVolumesFcOutput() IndexerClusterSpecVolumesFcOutput {
	return i.ToIndexerClusterSpecVolumesFcOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFcArgs) ToIndexerClusterSpecVolumesFcOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFcOutput)
}

func (i IndexerClusterSpecVolumesFcArgs) ToIndexerClusterSpecVolumesFcPtrOutput() IndexerClusterSpecVolumesFcPtrOutput {
	return i.ToIndexerClusterSpecVolumesFcPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFcArgs) ToIndexerClusterSpecVolumesFcPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFcOutput).ToIndexerClusterSpecVolumesFcPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesFcPtrInput is an input type that accepts IndexerClusterSpecVolumesFcArgs, IndexerClusterSpecVolumesFcPtr and IndexerClusterSpecVolumesFcPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFcPtrInput` via:
//
//          IndexerClusterSpecVolumesFcArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesFcPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFcPtrOutput() IndexerClusterSpecVolumesFcPtrOutput
	ToIndexerClusterSpecVolumesFcPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesFcPtrOutput
}

type indexerClusterSpecVolumesFcPtrType IndexerClusterSpecVolumesFcArgs

func IndexerClusterSpecVolumesFcPtr(v *IndexerClusterSpecVolumesFcArgs) IndexerClusterSpecVolumesFcPtrInput {
	return (*indexerClusterSpecVolumesFcPtrType)(v)
}

func (*indexerClusterSpecVolumesFcPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFc)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesFcPtrType) ToIndexerClusterSpecVolumesFcPtrOutput() IndexerClusterSpecVolumesFcPtrOutput {
	return i.ToIndexerClusterSpecVolumesFcPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesFcPtrType) ToIndexerClusterSpecVolumesFcPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFcPtrOutput)
}

// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
type IndexerClusterSpecVolumesFcOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFcOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFc)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFcOutput) ToIndexerClusterSpecVolumesFcOutput() IndexerClusterSpecVolumesFcOutput {
	return o
}

func (o IndexerClusterSpecVolumesFcOutput) ToIndexerClusterSpecVolumesFcOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcOutput {
	return o
}

func (o IndexerClusterSpecVolumesFcOutput) ToIndexerClusterSpecVolumesFcPtrOutput() IndexerClusterSpecVolumesFcPtrOutput {
	return o.ToIndexerClusterSpecVolumesFcPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesFcOutput) ToIndexerClusterSpecVolumesFcPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) *IndexerClusterSpecVolumesFc {
		return &v
	}).(IndexerClusterSpecVolumesFcPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesFcOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Optional: FC target lun number
func (o IndexerClusterSpecVolumesFcOutput) Lun() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) *int { return v.Lun }).(pulumi.IntPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesFcOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Optional: FC target worldwide names (WWNs)
func (o IndexerClusterSpecVolumesFcOutput) TargetWWNs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) []string { return v.TargetWWNs }).(pulumi.StringArrayOutput)
}

// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
func (o IndexerClusterSpecVolumesFcOutput) Wwids() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFc) []string { return v.Wwids }).(pulumi.StringArrayOutput)
}

type IndexerClusterSpecVolumesFcPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFcPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFc)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFcPtrOutput) ToIndexerClusterSpecVolumesFcPtrOutput() IndexerClusterSpecVolumesFcPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFcPtrOutput) ToIndexerClusterSpecVolumesFcPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFcPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFcPtrOutput) Elem() IndexerClusterSpecVolumesFcOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) IndexerClusterSpecVolumesFc { return *v }).(IndexerClusterSpecVolumesFcOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesFcPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Optional: FC target lun number
func (o IndexerClusterSpecVolumesFcPtrOutput) Lun() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) *int {
		if v == nil {
			return nil
		}
		return v.Lun
	}).(pulumi.IntPtrOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesFcPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Optional: FC target worldwide names (WWNs)
func (o IndexerClusterSpecVolumesFcPtrOutput) TargetWWNs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) []string {
		if v == nil {
			return nil
		}
		return v.TargetWWNs
	}).(pulumi.StringArrayOutput)
}

// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
func (o IndexerClusterSpecVolumesFcPtrOutput) Wwids() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFc) []string {
		if v == nil {
			return nil
		}
		return v.Wwids
	}).(pulumi.StringArrayOutput)
}

// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
type IndexerClusterSpecVolumesFlexVolume struct {
	// Driver is the name of the driver to use for this volume.
	Driver string `pulumi:"driver"`
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
	FsType *string `pulumi:"fsType"`
	// Optional: Extra command options if any.
	Options map[string]string `pulumi:"options"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
	SecretRef *IndexerClusterSpecVolumesFlexVolumeSecretRef `pulumi:"secretRef"`
}

// IndexerClusterSpecVolumesFlexVolumeInput is an input type that accepts IndexerClusterSpecVolumesFlexVolumeArgs and IndexerClusterSpecVolumesFlexVolumeOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlexVolumeInput` via:
//
//          IndexerClusterSpecVolumesFlexVolumeArgs{...}
type IndexerClusterSpecVolumesFlexVolumeInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlexVolumeOutput() IndexerClusterSpecVolumesFlexVolumeOutput
	ToIndexerClusterSpecVolumesFlexVolumeOutputWithContext(context.Context) IndexerClusterSpecVolumesFlexVolumeOutput
}

// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
type IndexerClusterSpecVolumesFlexVolumeArgs struct {
	// Driver is the name of the driver to use for this volume.
	Driver pulumi.StringInput `pulumi:"driver"`
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Optional: Extra command options if any.
	Options pulumi.StringMapInput `pulumi:"options"`
	// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
	SecretRef IndexerClusterSpecVolumesFlexVolumeSecretRefPtrInput `pulumi:"secretRef"`
}

func (IndexerClusterSpecVolumesFlexVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolume)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesFlexVolumeArgs) ToIndexerClusterSpecVolumesFlexVolumeOutput() IndexerClusterSpecVolumesFlexVolumeOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumeOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlexVolumeArgs) ToIndexerClusterSpecVolumesFlexVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeOutput)
}

func (i IndexerClusterSpecVolumesFlexVolumeArgs) ToIndexerClusterSpecVolumesFlexVolumePtrOutput() IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlexVolumeArgs) ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeOutput).ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesFlexVolumePtrInput is an input type that accepts IndexerClusterSpecVolumesFlexVolumeArgs, IndexerClusterSpecVolumesFlexVolumePtr and IndexerClusterSpecVolumesFlexVolumePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlexVolumePtrInput` via:
//
//          IndexerClusterSpecVolumesFlexVolumeArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesFlexVolumePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlexVolumePtrOutput() IndexerClusterSpecVolumesFlexVolumePtrOutput
	ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesFlexVolumePtrOutput
}

type indexerClusterSpecVolumesFlexVolumePtrType IndexerClusterSpecVolumesFlexVolumeArgs

func IndexerClusterSpecVolumesFlexVolumePtr(v *IndexerClusterSpecVolumesFlexVolumeArgs) IndexerClusterSpecVolumesFlexVolumePtrInput {
	return (*indexerClusterSpecVolumesFlexVolumePtrType)(v)
}

func (*indexerClusterSpecVolumesFlexVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlexVolume)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesFlexVolumePtrType) ToIndexerClusterSpecVolumesFlexVolumePtrOutput() IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesFlexVolumePtrType) ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumePtrOutput)
}

// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
type IndexerClusterSpecVolumesFlexVolumeOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlexVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlexVolumeOutput) ToIndexerClusterSpecVolumesFlexVolumeOutput() IndexerClusterSpecVolumesFlexVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeOutput) ToIndexerClusterSpecVolumesFlexVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeOutput) ToIndexerClusterSpecVolumesFlexVolumePtrOutput() IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return o.ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesFlexVolumeOutput) ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) *IndexerClusterSpecVolumesFlexVolume {
		return &v
	}).(IndexerClusterSpecVolumesFlexVolumePtrOutput)
}

// Driver is the name of the driver to use for this volume.
func (o IndexerClusterSpecVolumesFlexVolumeOutput) Driver() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) string { return v.Driver }).(pulumi.StringOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
func (o IndexerClusterSpecVolumesFlexVolumeOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Optional: Extra command options if any.
func (o IndexerClusterSpecVolumesFlexVolumeOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesFlexVolumeOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
func (o IndexerClusterSpecVolumesFlexVolumeOutput) SecretRef() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolume) *IndexerClusterSpecVolumesFlexVolumeSecretRef {
		return v.SecretRef
	}).(IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput)
}

type IndexerClusterSpecVolumesFlexVolumePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlexVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlexVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) ToIndexerClusterSpecVolumesFlexVolumePtrOutput() IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) ToIndexerClusterSpecVolumesFlexVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) Elem() IndexerClusterSpecVolumesFlexVolumeOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) IndexerClusterSpecVolumesFlexVolume { return *v }).(IndexerClusterSpecVolumesFlexVolumeOutput)
}

// Driver is the name of the driver to use for this volume.
func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) Driver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) *string {
		if v == nil {
			return nil
		}
		return &v.Driver
	}).(pulumi.StringPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Optional: Extra command options if any.
func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
func (o IndexerClusterSpecVolumesFlexVolumePtrOutput) SecretRef() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolume) *IndexerClusterSpecVolumesFlexVolumeSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput)
}

// Optional: Extra command options if any.
type IndexerClusterSpecVolumesFlexVolumeOptions struct {
}

// IndexerClusterSpecVolumesFlexVolumeOptionsInput is an input type that accepts IndexerClusterSpecVolumesFlexVolumeOptionsArgs and IndexerClusterSpecVolumesFlexVolumeOptionsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlexVolumeOptionsInput` via:
//
//          IndexerClusterSpecVolumesFlexVolumeOptionsArgs{...}
type IndexerClusterSpecVolumesFlexVolumeOptionsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlexVolumeOptionsOutput() IndexerClusterSpecVolumesFlexVolumeOptionsOutput
	ToIndexerClusterSpecVolumesFlexVolumeOptionsOutputWithContext(context.Context) IndexerClusterSpecVolumesFlexVolumeOptionsOutput
}

// Optional: Extra command options if any.
type IndexerClusterSpecVolumesFlexVolumeOptionsArgs struct {
}

func (IndexerClusterSpecVolumesFlexVolumeOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolumeOptions)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesFlexVolumeOptionsArgs) ToIndexerClusterSpecVolumesFlexVolumeOptionsOutput() IndexerClusterSpecVolumesFlexVolumeOptionsOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumeOptionsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlexVolumeOptionsArgs) ToIndexerClusterSpecVolumesFlexVolumeOptionsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeOptionsOutput)
}

// Optional: Extra command options if any.
type IndexerClusterSpecVolumesFlexVolumeOptionsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlexVolumeOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolumeOptions)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlexVolumeOptionsOutput) ToIndexerClusterSpecVolumesFlexVolumeOptionsOutput() IndexerClusterSpecVolumesFlexVolumeOptionsOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeOptionsOutput) ToIndexerClusterSpecVolumesFlexVolumeOptionsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeOptionsOutput {
	return o
}

// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
type IndexerClusterSpecVolumesFlexVolumeSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesFlexVolumeSecretRefInput is an input type that accepts IndexerClusterSpecVolumesFlexVolumeSecretRefArgs and IndexerClusterSpecVolumesFlexVolumeSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlexVolumeSecretRefInput` via:
//
//          IndexerClusterSpecVolumesFlexVolumeSecretRefArgs{...}
type IndexerClusterSpecVolumesFlexVolumeSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefOutput
	ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefOutput
}

// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
type IndexerClusterSpecVolumesFlexVolumeSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolumeSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeSecretRefOutput)
}

func (i IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeSecretRefOutput).ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesFlexVolumeSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesFlexVolumeSecretRefArgs, IndexerClusterSpecVolumesFlexVolumeSecretRefPtr and IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlexVolumeSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesFlexVolumeSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesFlexVolumeSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput
	ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput
}

type indexerClusterSpecVolumesFlexVolumeSecretRefPtrType IndexerClusterSpecVolumesFlexVolumeSecretRefArgs

func IndexerClusterSpecVolumesFlexVolumeSecretRefPtr(v *IndexerClusterSpecVolumesFlexVolumeSecretRefArgs) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrInput {
	return (*indexerClusterSpecVolumesFlexVolumeSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesFlexVolumeSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlexVolumeSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesFlexVolumeSecretRefPtrType) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesFlexVolumeSecretRefPtrType) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput)
}

// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
type IndexerClusterSpecVolumesFlexVolumeSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlexVolumeSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolumeSecretRef) *IndexerClusterSpecVolumesFlexVolumeSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesFlexVolumeSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlexVolumeSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlexVolumeSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput() IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput) ToIndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesFlexVolumeSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolumeSecretRef) IndexerClusterSpecVolumesFlexVolumeSecretRef {
		return *v
	}).(IndexerClusterSpecVolumesFlexVolumeSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlexVolumeSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
type IndexerClusterSpecVolumesFlocker struct {
	// Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
	DatasetName *string `pulumi:"datasetName"`
	// UUID of the dataset. This is unique identifier of a Flocker dataset
	DatasetUUID *string `pulumi:"datasetUUID"`
}

// IndexerClusterSpecVolumesFlockerInput is an input type that accepts IndexerClusterSpecVolumesFlockerArgs and IndexerClusterSpecVolumesFlockerOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlockerInput` via:
//
//          IndexerClusterSpecVolumesFlockerArgs{...}
type IndexerClusterSpecVolumesFlockerInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlockerOutput() IndexerClusterSpecVolumesFlockerOutput
	ToIndexerClusterSpecVolumesFlockerOutputWithContext(context.Context) IndexerClusterSpecVolumesFlockerOutput
}

// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
type IndexerClusterSpecVolumesFlockerArgs struct {
	// Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
	DatasetName pulumi.StringPtrInput `pulumi:"datasetName"`
	// UUID of the dataset. This is unique identifier of a Flocker dataset
	DatasetUUID pulumi.StringPtrInput `pulumi:"datasetUUID"`
}

func (IndexerClusterSpecVolumesFlockerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlocker)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesFlockerArgs) ToIndexerClusterSpecVolumesFlockerOutput() IndexerClusterSpecVolumesFlockerOutput {
	return i.ToIndexerClusterSpecVolumesFlockerOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlockerArgs) ToIndexerClusterSpecVolumesFlockerOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlockerOutput)
}

func (i IndexerClusterSpecVolumesFlockerArgs) ToIndexerClusterSpecVolumesFlockerPtrOutput() IndexerClusterSpecVolumesFlockerPtrOutput {
	return i.ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesFlockerArgs) ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlockerOutput).ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesFlockerPtrInput is an input type that accepts IndexerClusterSpecVolumesFlockerArgs, IndexerClusterSpecVolumesFlockerPtr and IndexerClusterSpecVolumesFlockerPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesFlockerPtrInput` via:
//
//          IndexerClusterSpecVolumesFlockerArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesFlockerPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesFlockerPtrOutput() IndexerClusterSpecVolumesFlockerPtrOutput
	ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesFlockerPtrOutput
}

type indexerClusterSpecVolumesFlockerPtrType IndexerClusterSpecVolumesFlockerArgs

func IndexerClusterSpecVolumesFlockerPtr(v *IndexerClusterSpecVolumesFlockerArgs) IndexerClusterSpecVolumesFlockerPtrInput {
	return (*indexerClusterSpecVolumesFlockerPtrType)(v)
}

func (*indexerClusterSpecVolumesFlockerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlocker)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesFlockerPtrType) ToIndexerClusterSpecVolumesFlockerPtrOutput() IndexerClusterSpecVolumesFlockerPtrOutput {
	return i.ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesFlockerPtrType) ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesFlockerPtrOutput)
}

// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
type IndexerClusterSpecVolumesFlockerOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlockerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesFlocker)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlockerOutput) ToIndexerClusterSpecVolumesFlockerOutput() IndexerClusterSpecVolumesFlockerOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlockerOutput) ToIndexerClusterSpecVolumesFlockerOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlockerOutput) ToIndexerClusterSpecVolumesFlockerPtrOutput() IndexerClusterSpecVolumesFlockerPtrOutput {
	return o.ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesFlockerOutput) ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlocker) *IndexerClusterSpecVolumesFlocker {
		return &v
	}).(IndexerClusterSpecVolumesFlockerPtrOutput)
}

// Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
func (o IndexerClusterSpecVolumesFlockerOutput) DatasetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlocker) *string { return v.DatasetName }).(pulumi.StringPtrOutput)
}

// UUID of the dataset. This is unique identifier of a Flocker dataset
func (o IndexerClusterSpecVolumesFlockerOutput) DatasetUUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesFlocker) *string { return v.DatasetUUID }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesFlockerPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesFlockerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesFlocker)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesFlockerPtrOutput) ToIndexerClusterSpecVolumesFlockerPtrOutput() IndexerClusterSpecVolumesFlockerPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlockerPtrOutput) ToIndexerClusterSpecVolumesFlockerPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesFlockerPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesFlockerPtrOutput) Elem() IndexerClusterSpecVolumesFlockerOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlocker) IndexerClusterSpecVolumesFlocker { return *v }).(IndexerClusterSpecVolumesFlockerOutput)
}

// Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
func (o IndexerClusterSpecVolumesFlockerPtrOutput) DatasetName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlocker) *string {
		if v == nil {
			return nil
		}
		return v.DatasetName
	}).(pulumi.StringPtrOutput)
}

// UUID of the dataset. This is unique identifier of a Flocker dataset
func (o IndexerClusterSpecVolumesFlockerPtrOutput) DatasetUUID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesFlocker) *string {
		if v == nil {
			return nil
		}
		return v.DatasetUUID
	}).(pulumi.StringPtrOutput)
}

// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
type IndexerClusterSpecVolumesGcePersistentDisk struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType *string `pulumi:"fsType"`
	// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	Partition *int `pulumi:"partition"`
	// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	PdName string `pulumi:"pdName"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	ReadOnly *bool `pulumi:"readOnly"`
}

// IndexerClusterSpecVolumesGcePersistentDiskInput is an input type that accepts IndexerClusterSpecVolumesGcePersistentDiskArgs and IndexerClusterSpecVolumesGcePersistentDiskOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGcePersistentDiskInput` via:
//
//          IndexerClusterSpecVolumesGcePersistentDiskArgs{...}
type IndexerClusterSpecVolumesGcePersistentDiskInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGcePersistentDiskOutput() IndexerClusterSpecVolumesGcePersistentDiskOutput
	ToIndexerClusterSpecVolumesGcePersistentDiskOutputWithContext(context.Context) IndexerClusterSpecVolumesGcePersistentDiskOutput
}

// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
type IndexerClusterSpecVolumesGcePersistentDiskArgs struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	Partition pulumi.IntPtrInput `pulumi:"partition"`
	// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	PdName pulumi.StringInput `pulumi:"pdName"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
}

func (IndexerClusterSpecVolumesGcePersistentDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGcePersistentDisk)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesGcePersistentDiskArgs) ToIndexerClusterSpecVolumesGcePersistentDiskOutput() IndexerClusterSpecVolumesGcePersistentDiskOutput {
	return i.ToIndexerClusterSpecVolumesGcePersistentDiskOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGcePersistentDiskArgs) ToIndexerClusterSpecVolumesGcePersistentDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGcePersistentDiskOutput)
}

func (i IndexerClusterSpecVolumesGcePersistentDiskArgs) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutput() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGcePersistentDiskArgs) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGcePersistentDiskOutput).ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesGcePersistentDiskPtrInput is an input type that accepts IndexerClusterSpecVolumesGcePersistentDiskArgs, IndexerClusterSpecVolumesGcePersistentDiskPtr and IndexerClusterSpecVolumesGcePersistentDiskPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGcePersistentDiskPtrInput` via:
//
//          IndexerClusterSpecVolumesGcePersistentDiskArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesGcePersistentDiskPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutput() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput
	ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesGcePersistentDiskPtrOutput
}

type indexerClusterSpecVolumesGcePersistentDiskPtrType IndexerClusterSpecVolumesGcePersistentDiskArgs

func IndexerClusterSpecVolumesGcePersistentDiskPtr(v *IndexerClusterSpecVolumesGcePersistentDiskArgs) IndexerClusterSpecVolumesGcePersistentDiskPtrInput {
	return (*indexerClusterSpecVolumesGcePersistentDiskPtrType)(v)
}

func (*indexerClusterSpecVolumesGcePersistentDiskPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGcePersistentDisk)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesGcePersistentDiskPtrType) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutput() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesGcePersistentDiskPtrType) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGcePersistentDiskPtrOutput)
}

// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
type IndexerClusterSpecVolumesGcePersistentDiskOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGcePersistentDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGcePersistentDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) ToIndexerClusterSpecVolumesGcePersistentDiskOutput() IndexerClusterSpecVolumesGcePersistentDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) ToIndexerClusterSpecVolumesGcePersistentDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutput() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return o.ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGcePersistentDisk) *IndexerClusterSpecVolumesGcePersistentDisk {
		return &v
	}).(IndexerClusterSpecVolumesGcePersistentDiskPtrOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGcePersistentDisk) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGcePersistentDisk) *int { return v.Partition }).(pulumi.IntPtrOutput)
}

// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) PdName() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGcePersistentDisk) string { return v.PdName }).(pulumi.StringOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGcePersistentDisk) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesGcePersistentDiskPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGcePersistentDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutput() IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) ToIndexerClusterSpecVolumesGcePersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGcePersistentDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) Elem() IndexerClusterSpecVolumesGcePersistentDiskOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGcePersistentDisk) IndexerClusterSpecVolumesGcePersistentDisk {
		return *v
	}).(IndexerClusterSpecVolumesGcePersistentDiskOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGcePersistentDisk) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) Partition() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGcePersistentDisk) *int {
		if v == nil {
			return nil
		}
		return v.Partition
	}).(pulumi.IntPtrOutput)
}

// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) PdName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGcePersistentDisk) *string {
		if v == nil {
			return nil
		}
		return &v.PdName
	}).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
func (o IndexerClusterSpecVolumesGcePersistentDiskPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGcePersistentDisk) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
type IndexerClusterSpecVolumesGitRepo struct {
	// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
	Directory *string `pulumi:"directory"`
	// Repository URL
	Repository string `pulumi:"repository"`
	// Commit hash for the specified revision.
	Revision *string `pulumi:"revision"`
}

// IndexerClusterSpecVolumesGitRepoInput is an input type that accepts IndexerClusterSpecVolumesGitRepoArgs and IndexerClusterSpecVolumesGitRepoOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGitRepoInput` via:
//
//          IndexerClusterSpecVolumesGitRepoArgs{...}
type IndexerClusterSpecVolumesGitRepoInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGitRepoOutput() IndexerClusterSpecVolumesGitRepoOutput
	ToIndexerClusterSpecVolumesGitRepoOutputWithContext(context.Context) IndexerClusterSpecVolumesGitRepoOutput
}

// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
type IndexerClusterSpecVolumesGitRepoArgs struct {
	// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
	Directory pulumi.StringPtrInput `pulumi:"directory"`
	// Repository URL
	Repository pulumi.StringInput `pulumi:"repository"`
	// Commit hash for the specified revision.
	Revision pulumi.StringPtrInput `pulumi:"revision"`
}

func (IndexerClusterSpecVolumesGitRepoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGitRepo)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesGitRepoArgs) ToIndexerClusterSpecVolumesGitRepoOutput() IndexerClusterSpecVolumesGitRepoOutput {
	return i.ToIndexerClusterSpecVolumesGitRepoOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGitRepoArgs) ToIndexerClusterSpecVolumesGitRepoOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGitRepoOutput)
}

func (i IndexerClusterSpecVolumesGitRepoArgs) ToIndexerClusterSpecVolumesGitRepoPtrOutput() IndexerClusterSpecVolumesGitRepoPtrOutput {
	return i.ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGitRepoArgs) ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGitRepoOutput).ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesGitRepoPtrInput is an input type that accepts IndexerClusterSpecVolumesGitRepoArgs, IndexerClusterSpecVolumesGitRepoPtr and IndexerClusterSpecVolumesGitRepoPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGitRepoPtrInput` via:
//
//          IndexerClusterSpecVolumesGitRepoArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesGitRepoPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGitRepoPtrOutput() IndexerClusterSpecVolumesGitRepoPtrOutput
	ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesGitRepoPtrOutput
}

type indexerClusterSpecVolumesGitRepoPtrType IndexerClusterSpecVolumesGitRepoArgs

func IndexerClusterSpecVolumesGitRepoPtr(v *IndexerClusterSpecVolumesGitRepoArgs) IndexerClusterSpecVolumesGitRepoPtrInput {
	return (*indexerClusterSpecVolumesGitRepoPtrType)(v)
}

func (*indexerClusterSpecVolumesGitRepoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGitRepo)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesGitRepoPtrType) ToIndexerClusterSpecVolumesGitRepoPtrOutput() IndexerClusterSpecVolumesGitRepoPtrOutput {
	return i.ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesGitRepoPtrType) ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGitRepoPtrOutput)
}

// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
type IndexerClusterSpecVolumesGitRepoOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGitRepoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGitRepo)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGitRepoOutput) ToIndexerClusterSpecVolumesGitRepoOutput() IndexerClusterSpecVolumesGitRepoOutput {
	return o
}

func (o IndexerClusterSpecVolumesGitRepoOutput) ToIndexerClusterSpecVolumesGitRepoOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoOutput {
	return o
}

func (o IndexerClusterSpecVolumesGitRepoOutput) ToIndexerClusterSpecVolumesGitRepoPtrOutput() IndexerClusterSpecVolumesGitRepoPtrOutput {
	return o.ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesGitRepoOutput) ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGitRepo) *IndexerClusterSpecVolumesGitRepo {
		return &v
	}).(IndexerClusterSpecVolumesGitRepoPtrOutput)
}

// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
func (o IndexerClusterSpecVolumesGitRepoOutput) Directory() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGitRepo) *string { return v.Directory }).(pulumi.StringPtrOutput)
}

// Repository URL
func (o IndexerClusterSpecVolumesGitRepoOutput) Repository() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGitRepo) string { return v.Repository }).(pulumi.StringOutput)
}

// Commit hash for the specified revision.
func (o IndexerClusterSpecVolumesGitRepoOutput) Revision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGitRepo) *string { return v.Revision }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesGitRepoPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGitRepoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGitRepo)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGitRepoPtrOutput) ToIndexerClusterSpecVolumesGitRepoPtrOutput() IndexerClusterSpecVolumesGitRepoPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGitRepoPtrOutput) ToIndexerClusterSpecVolumesGitRepoPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGitRepoPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGitRepoPtrOutput) Elem() IndexerClusterSpecVolumesGitRepoOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGitRepo) IndexerClusterSpecVolumesGitRepo { return *v }).(IndexerClusterSpecVolumesGitRepoOutput)
}

// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
func (o IndexerClusterSpecVolumesGitRepoPtrOutput) Directory() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGitRepo) *string {
		if v == nil {
			return nil
		}
		return v.Directory
	}).(pulumi.StringPtrOutput)
}

// Repository URL
func (o IndexerClusterSpecVolumesGitRepoPtrOutput) Repository() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGitRepo) *string {
		if v == nil {
			return nil
		}
		return &v.Repository
	}).(pulumi.StringPtrOutput)
}

// Commit hash for the specified revision.
func (o IndexerClusterSpecVolumesGitRepoPtrOutput) Revision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGitRepo) *string {
		if v == nil {
			return nil
		}
		return v.Revision
	}).(pulumi.StringPtrOutput)
}

// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
type IndexerClusterSpecVolumesGlusterfs struct {
	// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Endpoints string `pulumi:"endpoints"`
	// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Path string `pulumi:"path"`
	// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	ReadOnly *bool `pulumi:"readOnly"`
}

// IndexerClusterSpecVolumesGlusterfsInput is an input type that accepts IndexerClusterSpecVolumesGlusterfsArgs and IndexerClusterSpecVolumesGlusterfsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGlusterfsInput` via:
//
//          IndexerClusterSpecVolumesGlusterfsArgs{...}
type IndexerClusterSpecVolumesGlusterfsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGlusterfsOutput() IndexerClusterSpecVolumesGlusterfsOutput
	ToIndexerClusterSpecVolumesGlusterfsOutputWithContext(context.Context) IndexerClusterSpecVolumesGlusterfsOutput
}

// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
type IndexerClusterSpecVolumesGlusterfsArgs struct {
	// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Endpoints pulumi.StringInput `pulumi:"endpoints"`
	// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	Path pulumi.StringInput `pulumi:"path"`
	// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
}

func (IndexerClusterSpecVolumesGlusterfsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGlusterfs)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesGlusterfsArgs) ToIndexerClusterSpecVolumesGlusterfsOutput() IndexerClusterSpecVolumesGlusterfsOutput {
	return i.ToIndexerClusterSpecVolumesGlusterfsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGlusterfsArgs) ToIndexerClusterSpecVolumesGlusterfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGlusterfsOutput)
}

func (i IndexerClusterSpecVolumesGlusterfsArgs) ToIndexerClusterSpecVolumesGlusterfsPtrOutput() IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesGlusterfsArgs) ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGlusterfsOutput).ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesGlusterfsPtrInput is an input type that accepts IndexerClusterSpecVolumesGlusterfsArgs, IndexerClusterSpecVolumesGlusterfsPtr and IndexerClusterSpecVolumesGlusterfsPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesGlusterfsPtrInput` via:
//
//          IndexerClusterSpecVolumesGlusterfsArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesGlusterfsPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesGlusterfsPtrOutput() IndexerClusterSpecVolumesGlusterfsPtrOutput
	ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesGlusterfsPtrOutput
}

type indexerClusterSpecVolumesGlusterfsPtrType IndexerClusterSpecVolumesGlusterfsArgs

func IndexerClusterSpecVolumesGlusterfsPtr(v *IndexerClusterSpecVolumesGlusterfsArgs) IndexerClusterSpecVolumesGlusterfsPtrInput {
	return (*indexerClusterSpecVolumesGlusterfsPtrType)(v)
}

func (*indexerClusterSpecVolumesGlusterfsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGlusterfs)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesGlusterfsPtrType) ToIndexerClusterSpecVolumesGlusterfsPtrOutput() IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesGlusterfsPtrType) ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesGlusterfsPtrOutput)
}

// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
type IndexerClusterSpecVolumesGlusterfsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGlusterfsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesGlusterfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGlusterfsOutput) ToIndexerClusterSpecVolumesGlusterfsOutput() IndexerClusterSpecVolumesGlusterfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesGlusterfsOutput) ToIndexerClusterSpecVolumesGlusterfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesGlusterfsOutput) ToIndexerClusterSpecVolumesGlusterfsPtrOutput() IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return o.ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesGlusterfsOutput) ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGlusterfs) *IndexerClusterSpecVolumesGlusterfs {
		return &v
	}).(IndexerClusterSpecVolumesGlusterfsPtrOutput)
}

// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsOutput) Endpoints() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGlusterfs) string { return v.Endpoints }).(pulumi.StringOutput)
}

// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGlusterfs) string { return v.Path }).(pulumi.StringOutput)
}

// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesGlusterfs) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesGlusterfsPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesGlusterfsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesGlusterfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) ToIndexerClusterSpecVolumesGlusterfsPtrOutput() IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) ToIndexerClusterSpecVolumesGlusterfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesGlusterfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) Elem() IndexerClusterSpecVolumesGlusterfsOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGlusterfs) IndexerClusterSpecVolumesGlusterfs { return *v }).(IndexerClusterSpecVolumesGlusterfsOutput)
}

// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) Endpoints() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGlusterfs) *string {
		if v == nil {
			return nil
		}
		return &v.Endpoints
	}).(pulumi.StringPtrOutput)
}

// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGlusterfs) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
func (o IndexerClusterSpecVolumesGlusterfsPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesGlusterfs) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
type IndexerClusterSpecVolumesHostPath struct {
	// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Path string `pulumi:"path"`
	// Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Type *string `pulumi:"type"`
}

// IndexerClusterSpecVolumesHostPathInput is an input type that accepts IndexerClusterSpecVolumesHostPathArgs and IndexerClusterSpecVolumesHostPathOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesHostPathInput` via:
//
//          IndexerClusterSpecVolumesHostPathArgs{...}
type IndexerClusterSpecVolumesHostPathInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesHostPathOutput() IndexerClusterSpecVolumesHostPathOutput
	ToIndexerClusterSpecVolumesHostPathOutputWithContext(context.Context) IndexerClusterSpecVolumesHostPathOutput
}

// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
type IndexerClusterSpecVolumesHostPathArgs struct {
	// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Path pulumi.StringInput `pulumi:"path"`
	// Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (IndexerClusterSpecVolumesHostPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesHostPath)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesHostPathArgs) ToIndexerClusterSpecVolumesHostPathOutput() IndexerClusterSpecVolumesHostPathOutput {
	return i.ToIndexerClusterSpecVolumesHostPathOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesHostPathArgs) ToIndexerClusterSpecVolumesHostPathOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesHostPathOutput)
}

func (i IndexerClusterSpecVolumesHostPathArgs) ToIndexerClusterSpecVolumesHostPathPtrOutput() IndexerClusterSpecVolumesHostPathPtrOutput {
	return i.ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesHostPathArgs) ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesHostPathOutput).ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesHostPathPtrInput is an input type that accepts IndexerClusterSpecVolumesHostPathArgs, IndexerClusterSpecVolumesHostPathPtr and IndexerClusterSpecVolumesHostPathPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesHostPathPtrInput` via:
//
//          IndexerClusterSpecVolumesHostPathArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesHostPathPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesHostPathPtrOutput() IndexerClusterSpecVolumesHostPathPtrOutput
	ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesHostPathPtrOutput
}

type indexerClusterSpecVolumesHostPathPtrType IndexerClusterSpecVolumesHostPathArgs

func IndexerClusterSpecVolumesHostPathPtr(v *IndexerClusterSpecVolumesHostPathArgs) IndexerClusterSpecVolumesHostPathPtrInput {
	return (*indexerClusterSpecVolumesHostPathPtrType)(v)
}

func (*indexerClusterSpecVolumesHostPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesHostPath)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesHostPathPtrType) ToIndexerClusterSpecVolumesHostPathPtrOutput() IndexerClusterSpecVolumesHostPathPtrOutput {
	return i.ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesHostPathPtrType) ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesHostPathPtrOutput)
}

// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
type IndexerClusterSpecVolumesHostPathOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesHostPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesHostPath)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesHostPathOutput) ToIndexerClusterSpecVolumesHostPathOutput() IndexerClusterSpecVolumesHostPathOutput {
	return o
}

func (o IndexerClusterSpecVolumesHostPathOutput) ToIndexerClusterSpecVolumesHostPathOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathOutput {
	return o
}

func (o IndexerClusterSpecVolumesHostPathOutput) ToIndexerClusterSpecVolumesHostPathPtrOutput() IndexerClusterSpecVolumesHostPathPtrOutput {
	return o.ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesHostPathOutput) ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesHostPath) *IndexerClusterSpecVolumesHostPath {
		return &v
	}).(IndexerClusterSpecVolumesHostPathPtrOutput)
}

// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
func (o IndexerClusterSpecVolumesHostPathOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesHostPath) string { return v.Path }).(pulumi.StringOutput)
}

// Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
func (o IndexerClusterSpecVolumesHostPathOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesHostPath) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesHostPathPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesHostPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesHostPath)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesHostPathPtrOutput) ToIndexerClusterSpecVolumesHostPathPtrOutput() IndexerClusterSpecVolumesHostPathPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesHostPathPtrOutput) ToIndexerClusterSpecVolumesHostPathPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesHostPathPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesHostPathPtrOutput) Elem() IndexerClusterSpecVolumesHostPathOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesHostPath) IndexerClusterSpecVolumesHostPath { return *v }).(IndexerClusterSpecVolumesHostPathOutput)
}

// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
func (o IndexerClusterSpecVolumesHostPathPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesHostPath) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
func (o IndexerClusterSpecVolumesHostPathPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesHostPath) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
type IndexerClusterSpecVolumesIscsi struct {
	// whether support iSCSI Discovery CHAP authentication
	ChapAuthDiscovery *bool `pulumi:"chapAuthDiscovery"`
	// whether support iSCSI Session CHAP authentication
	ChapAuthSession *bool `pulumi:"chapAuthSession"`
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType *string `pulumi:"fsType"`
	// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
	InitiatorName *string `pulumi:"initiatorName"`
	// Target iSCSI Qualified Name.
	Iqn string `pulumi:"iqn"`
	// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
	IscsiInterface *string `pulumi:"iscsiInterface"`
	// iSCSI Target Lun number.
	Lun int `pulumi:"lun"`
	// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
	Portals []string `pulumi:"portals"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
	ReadOnly *bool `pulumi:"readOnly"`
	// CHAP Secret for iSCSI target and initiator authentication
	SecretRef *IndexerClusterSpecVolumesIscsiSecretRef `pulumi:"secretRef"`
	// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
	TargetPortal string `pulumi:"targetPortal"`
}

// IndexerClusterSpecVolumesIscsiInput is an input type that accepts IndexerClusterSpecVolumesIscsiArgs and IndexerClusterSpecVolumesIscsiOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesIscsiInput` via:
//
//          IndexerClusterSpecVolumesIscsiArgs{...}
type IndexerClusterSpecVolumesIscsiInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesIscsiOutput() IndexerClusterSpecVolumesIscsiOutput
	ToIndexerClusterSpecVolumesIscsiOutputWithContext(context.Context) IndexerClusterSpecVolumesIscsiOutput
}

// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
type IndexerClusterSpecVolumesIscsiArgs struct {
	// whether support iSCSI Discovery CHAP authentication
	ChapAuthDiscovery pulumi.BoolPtrInput `pulumi:"chapAuthDiscovery"`
	// whether support iSCSI Session CHAP authentication
	ChapAuthSession pulumi.BoolPtrInput `pulumi:"chapAuthSession"`
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
	InitiatorName pulumi.StringPtrInput `pulumi:"initiatorName"`
	// Target iSCSI Qualified Name.
	Iqn pulumi.StringInput `pulumi:"iqn"`
	// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
	IscsiInterface pulumi.StringPtrInput `pulumi:"iscsiInterface"`
	// iSCSI Target Lun number.
	Lun pulumi.IntInput `pulumi:"lun"`
	// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
	Portals pulumi.StringArrayInput `pulumi:"portals"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// CHAP Secret for iSCSI target and initiator authentication
	SecretRef IndexerClusterSpecVolumesIscsiSecretRefPtrInput `pulumi:"secretRef"`
	// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
	TargetPortal pulumi.StringInput `pulumi:"targetPortal"`
}

func (IndexerClusterSpecVolumesIscsiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesIscsi)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesIscsiArgs) ToIndexerClusterSpecVolumesIscsiOutput() IndexerClusterSpecVolumesIscsiOutput {
	return i.ToIndexerClusterSpecVolumesIscsiOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesIscsiArgs) ToIndexerClusterSpecVolumesIscsiOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiOutput)
}

func (i IndexerClusterSpecVolumesIscsiArgs) ToIndexerClusterSpecVolumesIscsiPtrOutput() IndexerClusterSpecVolumesIscsiPtrOutput {
	return i.ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesIscsiArgs) ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiOutput).ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesIscsiPtrInput is an input type that accepts IndexerClusterSpecVolumesIscsiArgs, IndexerClusterSpecVolumesIscsiPtr and IndexerClusterSpecVolumesIscsiPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesIscsiPtrInput` via:
//
//          IndexerClusterSpecVolumesIscsiArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesIscsiPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesIscsiPtrOutput() IndexerClusterSpecVolumesIscsiPtrOutput
	ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesIscsiPtrOutput
}

type indexerClusterSpecVolumesIscsiPtrType IndexerClusterSpecVolumesIscsiArgs

func IndexerClusterSpecVolumesIscsiPtr(v *IndexerClusterSpecVolumesIscsiArgs) IndexerClusterSpecVolumesIscsiPtrInput {
	return (*indexerClusterSpecVolumesIscsiPtrType)(v)
}

func (*indexerClusterSpecVolumesIscsiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesIscsi)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesIscsiPtrType) ToIndexerClusterSpecVolumesIscsiPtrOutput() IndexerClusterSpecVolumesIscsiPtrOutput {
	return i.ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesIscsiPtrType) ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiPtrOutput)
}

// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
type IndexerClusterSpecVolumesIscsiOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesIscsiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesIscsi)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesIscsiOutput) ToIndexerClusterSpecVolumesIscsiOutput() IndexerClusterSpecVolumesIscsiOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiOutput) ToIndexerClusterSpecVolumesIscsiOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiOutput) ToIndexerClusterSpecVolumesIscsiPtrOutput() IndexerClusterSpecVolumesIscsiPtrOutput {
	return o.ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesIscsiOutput) ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *IndexerClusterSpecVolumesIscsi {
		return &v
	}).(IndexerClusterSpecVolumesIscsiPtrOutput)
}

// whether support iSCSI Discovery CHAP authentication
func (o IndexerClusterSpecVolumesIscsiOutput) ChapAuthDiscovery() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *bool { return v.ChapAuthDiscovery }).(pulumi.BoolPtrOutput)
}

// whether support iSCSI Session CHAP authentication
func (o IndexerClusterSpecVolumesIscsiOutput) ChapAuthSession() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *bool { return v.ChapAuthSession }).(pulumi.BoolPtrOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesIscsiOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
func (o IndexerClusterSpecVolumesIscsiOutput) InitiatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *string { return v.InitiatorName }).(pulumi.StringPtrOutput)
}

// Target iSCSI Qualified Name.
func (o IndexerClusterSpecVolumesIscsiOutput) Iqn() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) string { return v.Iqn }).(pulumi.StringOutput)
}

// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
func (o IndexerClusterSpecVolumesIscsiOutput) IscsiInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *string { return v.IscsiInterface }).(pulumi.StringPtrOutput)
}

// iSCSI Target Lun number.
func (o IndexerClusterSpecVolumesIscsiOutput) Lun() pulumi.IntOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) int { return v.Lun }).(pulumi.IntOutput)
}

// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
func (o IndexerClusterSpecVolumesIscsiOutput) Portals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) []string { return v.Portals }).(pulumi.StringArrayOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
func (o IndexerClusterSpecVolumesIscsiOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// CHAP Secret for iSCSI target and initiator authentication
func (o IndexerClusterSpecVolumesIscsiOutput) SecretRef() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) *IndexerClusterSpecVolumesIscsiSecretRef { return v.SecretRef }).(IndexerClusterSpecVolumesIscsiSecretRefPtrOutput)
}

// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
func (o IndexerClusterSpecVolumesIscsiOutput) TargetPortal() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsi) string { return v.TargetPortal }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesIscsiPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesIscsiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesIscsi)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesIscsiPtrOutput) ToIndexerClusterSpecVolumesIscsiPtrOutput() IndexerClusterSpecVolumesIscsiPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiPtrOutput) ToIndexerClusterSpecVolumesIscsiPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiPtrOutput) Elem() IndexerClusterSpecVolumesIscsiOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) IndexerClusterSpecVolumesIscsi { return *v }).(IndexerClusterSpecVolumesIscsiOutput)
}

// whether support iSCSI Discovery CHAP authentication
func (o IndexerClusterSpecVolumesIscsiPtrOutput) ChapAuthDiscovery() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *bool {
		if v == nil {
			return nil
		}
		return v.ChapAuthDiscovery
	}).(pulumi.BoolPtrOutput)
}

// whether support iSCSI Session CHAP authentication
func (o IndexerClusterSpecVolumesIscsiPtrOutput) ChapAuthSession() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *bool {
		if v == nil {
			return nil
		}
		return v.ChapAuthSession
	}).(pulumi.BoolPtrOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesIscsiPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
func (o IndexerClusterSpecVolumesIscsiPtrOutput) InitiatorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *string {
		if v == nil {
			return nil
		}
		return v.InitiatorName
	}).(pulumi.StringPtrOutput)
}

// Target iSCSI Qualified Name.
func (o IndexerClusterSpecVolumesIscsiPtrOutput) Iqn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *string {
		if v == nil {
			return nil
		}
		return &v.Iqn
	}).(pulumi.StringPtrOutput)
}

// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
func (o IndexerClusterSpecVolumesIscsiPtrOutput) IscsiInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *string {
		if v == nil {
			return nil
		}
		return v.IscsiInterface
	}).(pulumi.StringPtrOutput)
}

// iSCSI Target Lun number.
func (o IndexerClusterSpecVolumesIscsiPtrOutput) Lun() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *int {
		if v == nil {
			return nil
		}
		return &v.Lun
	}).(pulumi.IntPtrOutput)
}

// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
func (o IndexerClusterSpecVolumesIscsiPtrOutput) Portals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) []string {
		if v == nil {
			return nil
		}
		return v.Portals
	}).(pulumi.StringArrayOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
func (o IndexerClusterSpecVolumesIscsiPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// CHAP Secret for iSCSI target and initiator authentication
func (o IndexerClusterSpecVolumesIscsiPtrOutput) SecretRef() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *IndexerClusterSpecVolumesIscsiSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesIscsiSecretRefPtrOutput)
}

// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
func (o IndexerClusterSpecVolumesIscsiPtrOutput) TargetPortal() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsi) *string {
		if v == nil {
			return nil
		}
		return &v.TargetPortal
	}).(pulumi.StringPtrOutput)
}

// CHAP Secret for iSCSI target and initiator authentication
type IndexerClusterSpecVolumesIscsiSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesIscsiSecretRefInput is an input type that accepts IndexerClusterSpecVolumesIscsiSecretRefArgs and IndexerClusterSpecVolumesIscsiSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesIscsiSecretRefInput` via:
//
//          IndexerClusterSpecVolumesIscsiSecretRefArgs{...}
type IndexerClusterSpecVolumesIscsiSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesIscsiSecretRefOutput() IndexerClusterSpecVolumesIscsiSecretRefOutput
	ToIndexerClusterSpecVolumesIscsiSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesIscsiSecretRefOutput
}

// CHAP Secret for iSCSI target and initiator authentication
type IndexerClusterSpecVolumesIscsiSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesIscsiSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesIscsiSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesIscsiSecretRefArgs) ToIndexerClusterSpecVolumesIscsiSecretRefOutput() IndexerClusterSpecVolumesIscsiSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesIscsiSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesIscsiSecretRefArgs) ToIndexerClusterSpecVolumesIscsiSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiSecretRefOutput)
}

func (i IndexerClusterSpecVolumesIscsiSecretRefArgs) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutput() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesIscsiSecretRefArgs) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiSecretRefOutput).ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesIscsiSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesIscsiSecretRefArgs, IndexerClusterSpecVolumesIscsiSecretRefPtr and IndexerClusterSpecVolumesIscsiSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesIscsiSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesIscsiSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesIscsiSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutput() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput
	ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesIscsiSecretRefPtrOutput
}

type indexerClusterSpecVolumesIscsiSecretRefPtrType IndexerClusterSpecVolumesIscsiSecretRefArgs

func IndexerClusterSpecVolumesIscsiSecretRefPtr(v *IndexerClusterSpecVolumesIscsiSecretRefArgs) IndexerClusterSpecVolumesIscsiSecretRefPtrInput {
	return (*indexerClusterSpecVolumesIscsiSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesIscsiSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesIscsiSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesIscsiSecretRefPtrType) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutput() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesIscsiSecretRefPtrType) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesIscsiSecretRefPtrOutput)
}

// CHAP Secret for iSCSI target and initiator authentication
type IndexerClusterSpecVolumesIscsiSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesIscsiSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesIscsiSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesIscsiSecretRefOutput) ToIndexerClusterSpecVolumesIscsiSecretRefOutput() IndexerClusterSpecVolumesIscsiSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiSecretRefOutput) ToIndexerClusterSpecVolumesIscsiSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiSecretRefOutput) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutput() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesIscsiSecretRefOutput) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsiSecretRef) *IndexerClusterSpecVolumesIscsiSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesIscsiSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesIscsiSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesIscsiSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesIscsiSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesIscsiSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesIscsiSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesIscsiSecretRefPtrOutput) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutput() IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiSecretRefPtrOutput) ToIndexerClusterSpecVolumesIscsiSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesIscsiSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesIscsiSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesIscsiSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsiSecretRef) IndexerClusterSpecVolumesIscsiSecretRef { return *v }).(IndexerClusterSpecVolumesIscsiSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesIscsiSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesIscsiSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
type IndexerClusterSpecVolumesNfs struct {
	// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Path string `pulumi:"path"`
	// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	ReadOnly *bool `pulumi:"readOnly"`
	// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Server string `pulumi:"server"`
}

// IndexerClusterSpecVolumesNfsInput is an input type that accepts IndexerClusterSpecVolumesNfsArgs and IndexerClusterSpecVolumesNfsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesNfsInput` via:
//
//          IndexerClusterSpecVolumesNfsArgs{...}
type IndexerClusterSpecVolumesNfsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesNfsOutput() IndexerClusterSpecVolumesNfsOutput
	ToIndexerClusterSpecVolumesNfsOutputWithContext(context.Context) IndexerClusterSpecVolumesNfsOutput
}

// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
type IndexerClusterSpecVolumesNfsArgs struct {
	// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Path pulumi.StringInput `pulumi:"path"`
	// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Server pulumi.StringInput `pulumi:"server"`
}

func (IndexerClusterSpecVolumesNfsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesNfs)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesNfsArgs) ToIndexerClusterSpecVolumesNfsOutput() IndexerClusterSpecVolumesNfsOutput {
	return i.ToIndexerClusterSpecVolumesNfsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesNfsArgs) ToIndexerClusterSpecVolumesNfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesNfsOutput)
}

func (i IndexerClusterSpecVolumesNfsArgs) ToIndexerClusterSpecVolumesNfsPtrOutput() IndexerClusterSpecVolumesNfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesNfsArgs) ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesNfsOutput).ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesNfsPtrInput is an input type that accepts IndexerClusterSpecVolumesNfsArgs, IndexerClusterSpecVolumesNfsPtr and IndexerClusterSpecVolumesNfsPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesNfsPtrInput` via:
//
//          IndexerClusterSpecVolumesNfsArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesNfsPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesNfsPtrOutput() IndexerClusterSpecVolumesNfsPtrOutput
	ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesNfsPtrOutput
}

type indexerClusterSpecVolumesNfsPtrType IndexerClusterSpecVolumesNfsArgs

func IndexerClusterSpecVolumesNfsPtr(v *IndexerClusterSpecVolumesNfsArgs) IndexerClusterSpecVolumesNfsPtrInput {
	return (*indexerClusterSpecVolumesNfsPtrType)(v)
}

func (*indexerClusterSpecVolumesNfsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesNfs)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesNfsPtrType) ToIndexerClusterSpecVolumesNfsPtrOutput() IndexerClusterSpecVolumesNfsPtrOutput {
	return i.ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesNfsPtrType) ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesNfsPtrOutput)
}

// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
type IndexerClusterSpecVolumesNfsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesNfsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesNfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesNfsOutput) ToIndexerClusterSpecVolumesNfsOutput() IndexerClusterSpecVolumesNfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesNfsOutput) ToIndexerClusterSpecVolumesNfsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsOutput {
	return o
}

func (o IndexerClusterSpecVolumesNfsOutput) ToIndexerClusterSpecVolumesNfsPtrOutput() IndexerClusterSpecVolumesNfsPtrOutput {
	return o.ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesNfsOutput) ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesNfs) *IndexerClusterSpecVolumesNfs {
		return &v
	}).(IndexerClusterSpecVolumesNfsPtrOutput)
}

// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesNfs) string { return v.Path }).(pulumi.StringOutput)
}

// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesNfs) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsOutput) Server() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesNfs) string { return v.Server }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesNfsPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesNfsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesNfs)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesNfsPtrOutput) ToIndexerClusterSpecVolumesNfsPtrOutput() IndexerClusterSpecVolumesNfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesNfsPtrOutput) ToIndexerClusterSpecVolumesNfsPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesNfsPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesNfsPtrOutput) Elem() IndexerClusterSpecVolumesNfsOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesNfs) IndexerClusterSpecVolumesNfs { return *v }).(IndexerClusterSpecVolumesNfsOutput)
}

// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesNfs) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesNfs) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
func (o IndexerClusterSpecVolumesNfsPtrOutput) Server() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesNfs) *string {
		if v == nil {
			return nil
		}
		return &v.Server
	}).(pulumi.StringPtrOutput)
}

// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type IndexerClusterSpecVolumesPersistentVolumeClaim struct {
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName string `pulumi:"claimName"`
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly *bool `pulumi:"readOnly"`
}

// IndexerClusterSpecVolumesPersistentVolumeClaimInput is an input type that accepts IndexerClusterSpecVolumesPersistentVolumeClaimArgs and IndexerClusterSpecVolumesPersistentVolumeClaimOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPersistentVolumeClaimInput` via:
//
//          IndexerClusterSpecVolumesPersistentVolumeClaimArgs{...}
type IndexerClusterSpecVolumesPersistentVolumeClaimInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPersistentVolumeClaimOutput() IndexerClusterSpecVolumesPersistentVolumeClaimOutput
	ToIndexerClusterSpecVolumesPersistentVolumeClaimOutputWithContext(context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimOutput
}

// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type IndexerClusterSpecVolumesPersistentVolumeClaimArgs struct {
	// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	ClaimName pulumi.StringInput `pulumi:"claimName"`
	// Will force the ReadOnly setting in VolumeMounts. Default false.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
}

func (IndexerClusterSpecVolumesPersistentVolumeClaimArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPersistentVolumeClaim)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesPersistentVolumeClaimArgs) ToIndexerClusterSpecVolumesPersistentVolumeClaimOutput() IndexerClusterSpecVolumesPersistentVolumeClaimOutput {
	return i.ToIndexerClusterSpecVolumesPersistentVolumeClaimOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPersistentVolumeClaimArgs) ToIndexerClusterSpecVolumesPersistentVolumeClaimOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPersistentVolumeClaimOutput)
}

func (i IndexerClusterSpecVolumesPersistentVolumeClaimArgs) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return i.ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPersistentVolumeClaimArgs) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPersistentVolumeClaimOutput).ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesPersistentVolumeClaimPtrInput is an input type that accepts IndexerClusterSpecVolumesPersistentVolumeClaimArgs, IndexerClusterSpecVolumesPersistentVolumeClaimPtr and IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPersistentVolumeClaimPtrInput` via:
//
//          IndexerClusterSpecVolumesPersistentVolumeClaimArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesPersistentVolumeClaimPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput
	ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput
}

type indexerClusterSpecVolumesPersistentVolumeClaimPtrType IndexerClusterSpecVolumesPersistentVolumeClaimArgs

func IndexerClusterSpecVolumesPersistentVolumeClaimPtr(v *IndexerClusterSpecVolumesPersistentVolumeClaimArgs) IndexerClusterSpecVolumesPersistentVolumeClaimPtrInput {
	return (*indexerClusterSpecVolumesPersistentVolumeClaimPtrType)(v)
}

func (*indexerClusterSpecVolumesPersistentVolumeClaimPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPersistentVolumeClaim)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesPersistentVolumeClaimPtrType) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return i.ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesPersistentVolumeClaimPtrType) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput)
}

// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
type IndexerClusterSpecVolumesPersistentVolumeClaimOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPersistentVolumeClaim)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimOutput() IndexerClusterSpecVolumesPersistentVolumeClaimOutput {
	return o
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimOutput {
	return o
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return o.ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPersistentVolumeClaim) *IndexerClusterSpecVolumesPersistentVolumeClaim {
		return &v
	}).(IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput)
}

// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ClaimName() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPersistentVolumeClaim) string { return v.ClaimName }).(pulumi.StringOutput)
}

// Will force the ReadOnly setting in VolumeMounts. Default false.
func (o IndexerClusterSpecVolumesPersistentVolumeClaimOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPersistentVolumeClaim) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPersistentVolumeClaim)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput() IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) ToIndexerClusterSpecVolumesPersistentVolumeClaimPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) Elem() IndexerClusterSpecVolumesPersistentVolumeClaimOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPersistentVolumeClaim) IndexerClusterSpecVolumesPersistentVolumeClaim {
		return *v
	}).(IndexerClusterSpecVolumesPersistentVolumeClaimOutput)
}

// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
func (o IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) ClaimName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPersistentVolumeClaim) *string {
		if v == nil {
			return nil
		}
		return &v.ClaimName
	}).(pulumi.StringPtrOutput)
}

// Will force the ReadOnly setting in VolumeMounts. Default false.
func (o IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPersistentVolumeClaim) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPhotonPersistentDisk struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType *string `pulumi:"fsType"`
	// ID that identifies Photon Controller persistent disk
	PdID string `pulumi:"pdID"`
}

// IndexerClusterSpecVolumesPhotonPersistentDiskInput is an input type that accepts IndexerClusterSpecVolumesPhotonPersistentDiskArgs and IndexerClusterSpecVolumesPhotonPersistentDiskOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPhotonPersistentDiskInput` via:
//
//          IndexerClusterSpecVolumesPhotonPersistentDiskArgs{...}
type IndexerClusterSpecVolumesPhotonPersistentDiskInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPhotonPersistentDiskOutput() IndexerClusterSpecVolumesPhotonPersistentDiskOutput
	ToIndexerClusterSpecVolumesPhotonPersistentDiskOutputWithContext(context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskOutput
}

// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPhotonPersistentDiskArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// ID that identifies Photon Controller persistent disk
	PdID pulumi.StringInput `pulumi:"pdID"`
}

func (IndexerClusterSpecVolumesPhotonPersistentDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPhotonPersistentDisk)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesPhotonPersistentDiskArgs) ToIndexerClusterSpecVolumesPhotonPersistentDiskOutput() IndexerClusterSpecVolumesPhotonPersistentDiskOutput {
	return i.ToIndexerClusterSpecVolumesPhotonPersistentDiskOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPhotonPersistentDiskArgs) ToIndexerClusterSpecVolumesPhotonPersistentDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPhotonPersistentDiskOutput)
}

func (i IndexerClusterSpecVolumesPhotonPersistentDiskArgs) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPhotonPersistentDiskArgs) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPhotonPersistentDiskOutput).ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesPhotonPersistentDiskPtrInput is an input type that accepts IndexerClusterSpecVolumesPhotonPersistentDiskArgs, IndexerClusterSpecVolumesPhotonPersistentDiskPtr and IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPhotonPersistentDiskPtrInput` via:
//
//          IndexerClusterSpecVolumesPhotonPersistentDiskArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesPhotonPersistentDiskPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput
	ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput
}

type indexerClusterSpecVolumesPhotonPersistentDiskPtrType IndexerClusterSpecVolumesPhotonPersistentDiskArgs

func IndexerClusterSpecVolumesPhotonPersistentDiskPtr(v *IndexerClusterSpecVolumesPhotonPersistentDiskArgs) IndexerClusterSpecVolumesPhotonPersistentDiskPtrInput {
	return (*indexerClusterSpecVolumesPhotonPersistentDiskPtrType)(v)
}

func (*indexerClusterSpecVolumesPhotonPersistentDiskPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPhotonPersistentDisk)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesPhotonPersistentDiskPtrType) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return i.ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesPhotonPersistentDiskPtrType) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput)
}

// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPhotonPersistentDiskOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPhotonPersistentDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPhotonPersistentDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskOutput() IndexerClusterSpecVolumesPhotonPersistentDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskOutput {
	return o
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return o.ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPhotonPersistentDisk) *IndexerClusterSpecVolumesPhotonPersistentDisk {
		return &v
	}).(IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPhotonPersistentDisk) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// ID that identifies Photon Controller persistent disk
func (o IndexerClusterSpecVolumesPhotonPersistentDiskOutput) PdID() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPhotonPersistentDisk) string { return v.PdID }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPhotonPersistentDisk)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput() IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) ToIndexerClusterSpecVolumesPhotonPersistentDiskPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) Elem() IndexerClusterSpecVolumesPhotonPersistentDiskOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPhotonPersistentDisk) IndexerClusterSpecVolumesPhotonPersistentDisk {
		return *v
	}).(IndexerClusterSpecVolumesPhotonPersistentDiskOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPhotonPersistentDisk) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// ID that identifies Photon Controller persistent disk
func (o IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput) PdID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPhotonPersistentDisk) *string {
		if v == nil {
			return nil
		}
		return &v.PdID
	}).(pulumi.StringPtrOutput)
}

// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPortworxVolume struct {
	// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
	FsType *string `pulumi:"fsType"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// VolumeID uniquely identifies a Portworx volume
	VolumeID string `pulumi:"volumeID"`
}

// IndexerClusterSpecVolumesPortworxVolumeInput is an input type that accepts IndexerClusterSpecVolumesPortworxVolumeArgs and IndexerClusterSpecVolumesPortworxVolumeOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPortworxVolumeInput` via:
//
//          IndexerClusterSpecVolumesPortworxVolumeArgs{...}
type IndexerClusterSpecVolumesPortworxVolumeInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPortworxVolumeOutput() IndexerClusterSpecVolumesPortworxVolumeOutput
	ToIndexerClusterSpecVolumesPortworxVolumeOutputWithContext(context.Context) IndexerClusterSpecVolumesPortworxVolumeOutput
}

// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPortworxVolumeArgs struct {
	// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// VolumeID uniquely identifies a Portworx volume
	VolumeID pulumi.StringInput `pulumi:"volumeID"`
}

func (IndexerClusterSpecVolumesPortworxVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPortworxVolume)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesPortworxVolumeArgs) ToIndexerClusterSpecVolumesPortworxVolumeOutput() IndexerClusterSpecVolumesPortworxVolumeOutput {
	return i.ToIndexerClusterSpecVolumesPortworxVolumeOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPortworxVolumeArgs) ToIndexerClusterSpecVolumesPortworxVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPortworxVolumeOutput)
}

func (i IndexerClusterSpecVolumesPortworxVolumeArgs) ToIndexerClusterSpecVolumesPortworxVolumePtrOutput() IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesPortworxVolumeArgs) ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPortworxVolumeOutput).ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesPortworxVolumePtrInput is an input type that accepts IndexerClusterSpecVolumesPortworxVolumeArgs, IndexerClusterSpecVolumesPortworxVolumePtr and IndexerClusterSpecVolumesPortworxVolumePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesPortworxVolumePtrInput` via:
//
//          IndexerClusterSpecVolumesPortworxVolumeArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesPortworxVolumePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesPortworxVolumePtrOutput() IndexerClusterSpecVolumesPortworxVolumePtrOutput
	ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesPortworxVolumePtrOutput
}

type indexerClusterSpecVolumesPortworxVolumePtrType IndexerClusterSpecVolumesPortworxVolumeArgs

func IndexerClusterSpecVolumesPortworxVolumePtr(v *IndexerClusterSpecVolumesPortworxVolumeArgs) IndexerClusterSpecVolumesPortworxVolumePtrInput {
	return (*indexerClusterSpecVolumesPortworxVolumePtrType)(v)
}

func (*indexerClusterSpecVolumesPortworxVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPortworxVolume)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesPortworxVolumePtrType) ToIndexerClusterSpecVolumesPortworxVolumePtrOutput() IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesPortworxVolumePtrType) ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesPortworxVolumePtrOutput)
}

// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesPortworxVolumeOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPortworxVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesPortworxVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPortworxVolumeOutput) ToIndexerClusterSpecVolumesPortworxVolumeOutput() IndexerClusterSpecVolumesPortworxVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesPortworxVolumeOutput) ToIndexerClusterSpecVolumesPortworxVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesPortworxVolumeOutput) ToIndexerClusterSpecVolumesPortworxVolumePtrOutput() IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return o.ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesPortworxVolumeOutput) ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPortworxVolume) *IndexerClusterSpecVolumesPortworxVolume {
		return &v
	}).(IndexerClusterSpecVolumesPortworxVolumePtrOutput)
}

// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesPortworxVolumeOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPortworxVolume) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesPortworxVolumeOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPortworxVolume) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// VolumeID uniquely identifies a Portworx volume
func (o IndexerClusterSpecVolumesPortworxVolumeOutput) VolumeID() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesPortworxVolume) string { return v.VolumeID }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesPortworxVolumePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesPortworxVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesPortworxVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) ToIndexerClusterSpecVolumesPortworxVolumePtrOutput() IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) ToIndexerClusterSpecVolumesPortworxVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesPortworxVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) Elem() IndexerClusterSpecVolumesPortworxVolumeOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPortworxVolume) IndexerClusterSpecVolumesPortworxVolume { return *v }).(IndexerClusterSpecVolumesPortworxVolumeOutput)
}

// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPortworxVolume) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPortworxVolume) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// VolumeID uniquely identifies a Portworx volume
func (o IndexerClusterSpecVolumesPortworxVolumePtrOutput) VolumeID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesPortworxVolume) *string {
		if v == nil {
			return nil
		}
		return &v.VolumeID
	}).(pulumi.StringPtrOutput)
}

// Items for all in one resources secrets, configmaps, and downward API
type IndexerClusterSpecVolumesProjected struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// list of volume projections
	Sources []IndexerClusterSpecVolumesProjectedSources `pulumi:"sources"`
}

// IndexerClusterSpecVolumesProjectedInput is an input type that accepts IndexerClusterSpecVolumesProjectedArgs and IndexerClusterSpecVolumesProjectedOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedInput` via:
//
//          IndexerClusterSpecVolumesProjectedArgs{...}
type IndexerClusterSpecVolumesProjectedInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedOutput() IndexerClusterSpecVolumesProjectedOutput
	ToIndexerClusterSpecVolumesProjectedOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedOutput
}

// Items for all in one resources secrets, configmaps, and downward API
type IndexerClusterSpecVolumesProjectedArgs struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// list of volume projections
	Sources IndexerClusterSpecVolumesProjectedSourcesArrayInput `pulumi:"sources"`
}

func (IndexerClusterSpecVolumesProjectedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjected)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedArgs) ToIndexerClusterSpecVolumesProjectedOutput() IndexerClusterSpecVolumesProjectedOutput {
	return i.ToIndexerClusterSpecVolumesProjectedOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedArgs) ToIndexerClusterSpecVolumesProjectedOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedOutput)
}

func (i IndexerClusterSpecVolumesProjectedArgs) ToIndexerClusterSpecVolumesProjectedPtrOutput() IndexerClusterSpecVolumesProjectedPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedArgs) ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedOutput).ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedArgs, IndexerClusterSpecVolumesProjectedPtr and IndexerClusterSpecVolumesProjectedPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedPtrOutput() IndexerClusterSpecVolumesProjectedPtrOutput
	ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedPtrOutput
}

type indexerClusterSpecVolumesProjectedPtrType IndexerClusterSpecVolumesProjectedArgs

func IndexerClusterSpecVolumesProjectedPtr(v *IndexerClusterSpecVolumesProjectedArgs) IndexerClusterSpecVolumesProjectedPtrInput {
	return (*indexerClusterSpecVolumesProjectedPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjected)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedPtrType) ToIndexerClusterSpecVolumesProjectedPtrOutput() IndexerClusterSpecVolumesProjectedPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedPtrType) ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedPtrOutput)
}

// Items for all in one resources secrets, configmaps, and downward API
type IndexerClusterSpecVolumesProjectedOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjected)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedOutput) ToIndexerClusterSpecVolumesProjectedOutput() IndexerClusterSpecVolumesProjectedOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedOutput) ToIndexerClusterSpecVolumesProjectedOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedOutput) ToIndexerClusterSpecVolumesProjectedPtrOutput() IndexerClusterSpecVolumesProjectedPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedOutput) ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjected) *IndexerClusterSpecVolumesProjected {
		return &v
	}).(IndexerClusterSpecVolumesProjectedPtrOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesProjectedOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjected) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// list of volume projections
func (o IndexerClusterSpecVolumesProjectedOutput) Sources() IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjected) []IndexerClusterSpecVolumesProjectedSources {
		return v.Sources
	}).(IndexerClusterSpecVolumesProjectedSourcesArrayOutput)
}

type IndexerClusterSpecVolumesProjectedPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjected)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedPtrOutput) ToIndexerClusterSpecVolumesProjectedPtrOutput() IndexerClusterSpecVolumesProjectedPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedPtrOutput) ToIndexerClusterSpecVolumesProjectedPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedPtrOutput) Elem() IndexerClusterSpecVolumesProjectedOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjected) IndexerClusterSpecVolumesProjected { return *v }).(IndexerClusterSpecVolumesProjectedOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesProjectedPtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjected) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// list of volume projections
func (o IndexerClusterSpecVolumesProjectedPtrOutput) Sources() IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjected) []IndexerClusterSpecVolumesProjectedSources {
		if v == nil {
			return nil
		}
		return v.Sources
	}).(IndexerClusterSpecVolumesProjectedSourcesArrayOutput)
}

// Projection that may be projected along with other supported volume types
type IndexerClusterSpecVolumesProjectedSources struct {
	// information about the configMap data to project
	ConfigMap *IndexerClusterSpecVolumesProjectedSourcesConfigMap `pulumi:"configMap"`
	// information about the downwardAPI data to project
	DownwardAPI *IndexerClusterSpecVolumesProjectedSourcesDownwardAPI `pulumi:"downwardAPI"`
	// information about the secret data to project
	Secret *IndexerClusterSpecVolumesProjectedSourcesSecret `pulumi:"secret"`
	// information about the serviceAccountToken data to project
	ServiceAccountToken *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken `pulumi:"serviceAccountToken"`
}

// IndexerClusterSpecVolumesProjectedSourcesInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesArgs and IndexerClusterSpecVolumesProjectedSourcesOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesOutput() IndexerClusterSpecVolumesProjectedSourcesOutput
	ToIndexerClusterSpecVolumesProjectedSourcesOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesOutput
}

// Projection that may be projected along with other supported volume types
type IndexerClusterSpecVolumesProjectedSourcesArgs struct {
	// information about the configMap data to project
	ConfigMap IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrInput `pulumi:"configMap"`
	// information about the downwardAPI data to project
	DownwardAPI IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrInput `pulumi:"downwardAPI"`
	// information about the secret data to project
	Secret IndexerClusterSpecVolumesProjectedSourcesSecretPtrInput `pulumi:"secret"`
	// information about the serviceAccountToken data to project
	ServiceAccountToken IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrInput `pulumi:"serviceAccountToken"`
}

func (IndexerClusterSpecVolumesProjectedSourcesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSources)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesArgs) ToIndexerClusterSpecVolumesProjectedSourcesOutput() IndexerClusterSpecVolumesProjectedSourcesOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesArgs) ToIndexerClusterSpecVolumesProjectedSourcesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesOutput)
}

// IndexerClusterSpecVolumesProjectedSourcesArrayInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesArray and IndexerClusterSpecVolumesProjectedSourcesArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesArrayInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesArray{ IndexerClusterSpecVolumesProjectedSourcesArgs{...} }
type IndexerClusterSpecVolumesProjectedSourcesArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesArrayOutput() IndexerClusterSpecVolumesProjectedSourcesArrayOutput
	ToIndexerClusterSpecVolumesProjectedSourcesArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesArrayOutput
}

type IndexerClusterSpecVolumesProjectedSourcesArray []IndexerClusterSpecVolumesProjectedSourcesInput

func (IndexerClusterSpecVolumesProjectedSourcesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSources)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesArray) ToIndexerClusterSpecVolumesProjectedSourcesArrayOutput() IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesArray) ToIndexerClusterSpecVolumesProjectedSourcesArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesArrayOutput)
}

// Projection that may be projected along with other supported volume types
type IndexerClusterSpecVolumesProjectedSourcesOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSources)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesOutput) ToIndexerClusterSpecVolumesProjectedSourcesOutput() IndexerClusterSpecVolumesProjectedSourcesOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesOutput) ToIndexerClusterSpecVolumesProjectedSourcesOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesOutput {
	return o
}

// information about the configMap data to project
func (o IndexerClusterSpecVolumesProjectedSourcesOutput) ConfigMap() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSources) *IndexerClusterSpecVolumesProjectedSourcesConfigMap {
		return v.ConfigMap
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput)
}

// information about the downwardAPI data to project
func (o IndexerClusterSpecVolumesProjectedSourcesOutput) DownwardAPI() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSources) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPI {
		return v.DownwardAPI
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput)
}

// information about the secret data to project
func (o IndexerClusterSpecVolumesProjectedSourcesOutput) Secret() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSources) *IndexerClusterSpecVolumesProjectedSourcesSecret {
		return v.Secret
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput)
}

// information about the serviceAccountToken data to project
func (o IndexerClusterSpecVolumesProjectedSourcesOutput) ServiceAccountToken() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSources) *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken {
		return v.ServiceAccountToken
	}).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSources)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesArrayOutput() IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesProjectedSourcesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesProjectedSources {
		return vs[0].([]IndexerClusterSpecVolumesProjectedSources)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesProjectedSourcesOutput)
}

// information about the configMap data to project
type IndexerClusterSpecVolumesProjectedSourcesConfigMap struct {
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []IndexerClusterSpecVolumesProjectedSourcesConfigMapItems `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
	// Specify whether the ConfigMap or its keys must be defined
	Optional *bool `pulumi:"optional"`
}

// IndexerClusterSpecVolumesProjectedSourcesConfigMapInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesConfigMap and IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesConfigMapInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesConfigMap{ "key": IndexerClusterSpecVolumesProjectedSourcesConfigArgs{...} }
type IndexerClusterSpecVolumesProjectedSourcesConfigMapInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput
	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput
}

// information about the configMap data to project
type IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs struct {
	// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayInput `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specify whether the ConfigMap or its keys must be defined
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesConfigMap)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput).ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs, IndexerClusterSpecVolumesProjectedSourcesConfigMapPtr and IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesConfigMapPtrType IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs

func IndexerClusterSpecVolumesProjectedSourcesConfigMapPtr(v *IndexerClusterSpecVolumesProjectedSourcesConfigMapArgs) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesConfigMapPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesConfigMapPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesConfigMap)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesConfigMapPtrType) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesConfigMapPtrType) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput)
}

// information about the configMap data to project
type IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesConfigMap)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMap) *IndexerClusterSpecVolumesProjectedSourcesConfigMap {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) Items() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMap) []IndexerClusterSpecVolumesProjectedSourcesConfigMapItems {
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMap) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specify whether the ConfigMap or its keys must be defined
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMap) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesConfigMap)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesConfigMap) IndexerClusterSpecVolumesProjectedSourcesConfigMap {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) Items() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesConfigMap) []IndexerClusterSpecVolumesProjectedSourcesConfigMapItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesConfigMap) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specify whether the ConfigMap or its keys must be defined
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesConfigMap) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesConfigMapItems struct {
	// The key to project.
	Key string `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path string `pulumi:"path"`
}

// IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs and IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput
	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs struct {
	// The key to project.
	Key pulumi.StringInput `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesConfigMapItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput)
}

// IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray and IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray{ IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArgs{...} }
type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput
	ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput
}

type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray []IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsInput

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesConfigMapItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesConfigMapItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput {
	return o
}

// The key to project.
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMapItems) string { return v.Key }).(pulumi.StringOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMapItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesConfigMapItems) string { return v.Path }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesConfigMapItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesProjectedSourcesConfigMapItems {
		return vs[0].([]IndexerClusterSpecVolumesProjectedSourcesConfigMapItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput)
}

// information about the downwardAPI data to project
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPI struct {
	// Items is a list of DownwardAPIVolume file
	Items []IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems `pulumi:"items"`
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput
}

// information about the downwardAPI data to project
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs struct {
	// Items is a list of DownwardAPIVolume file
	Items IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayInput `pulumi:"items"`
}

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPI)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput).ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs, IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtr and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrType IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs

func IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtr(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIArgs) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPI)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput)
}

// information about the downwardAPI data to project
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPI)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPI) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPI {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput)
}

// Items is a list of DownwardAPIVolume file
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput) Items() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPI) []IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems {
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPI)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPI) IndexerClusterSpecVolumesProjectedSourcesDownwardAPI {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput)
}

// Items is a list of DownwardAPIVolume file
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput) Items() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPI) []IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput)
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems struct {
	// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
	FieldRef *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef `pulumi:"fieldRef"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
	Path string `pulumi:"path"`
	// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
	ResourceFieldRef *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef `pulumi:"resourceFieldRef"`
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs struct {
	// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
	FieldRef IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrInput `pulumi:"fieldRef"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
	Path pulumi.StringInput `pulumi:"path"`
	// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
	ResourceFieldRef IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrInput `pulumi:"resourceFieldRef"`
}

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput)
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray{ IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArgs{...} }
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput
}

type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray []IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsInput

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput)
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput {
	return o
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) FieldRef() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
		return v.FieldRef
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems) string { return v.Path }).(pulumi.StringOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput) ResourceFieldRef() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
		return v.ResourceFieldRef
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems {
		return vs[0].([]IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput)
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion *string `pulumi:"apiVersion"`
	// Path of the field to select in the specified API version.
	FieldPath string `pulumi:"fieldPath"`
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Path of the field to select in the specified API version.
	FieldPath pulumi.StringInput `pulumi:"fieldPath"`
}

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput).ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs, IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtr and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrType IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs

func IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtr(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefArgs) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput)
}

// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput)
}

// Version of the schema the FieldPath is written in terms of, defaults to "v1".
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Path of the field to select in the specified API version.
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput) FieldPath() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) string { return v.FieldPath }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput)
}

// Version of the schema the FieldPath is written in terms of, defaults to "v1".
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// Path of the field to select in the specified API version.
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef) *string {
		if v == nil {
			return nil
		}
		return &v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef struct {
	// Container name: required for volumes, optional for env vars
	ContainerName *string `pulumi:"containerName"`
	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor *string `pulumi:"divisor"`
	// Required: resource to select
	Resource string `pulumi:"resource"`
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs struct {
	// Container name: required for volumes, optional for env vars
	ContainerName pulumi.StringPtrInput `pulumi:"containerName"`
	// Specifies the output format of the exposed resources, defaults to "1"
	Divisor pulumi.StringPtrInput `pulumi:"divisor"`
	// Required: resource to select
	Resource pulumi.StringInput `pulumi:"resource"`
}

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput).ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs, IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtr and IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrType IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs

func IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtr(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefArgs) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrType) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput)
}

// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput)
}

// Container name: required for volumes, optional for env vars
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) ContainerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *string {
		return v.ContainerName
	}).(pulumi.StringPtrOutput)
}

// Specifies the output format of the exposed resources, defaults to "1"
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) Divisor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *string {
		return v.Divisor
	}).(pulumi.StringPtrOutput)
}

// Required: resource to select
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput) Resource() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) string {
		return v.Resource
	}).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput)
}

// Container name: required for volumes, optional for env vars
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) ContainerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.ContainerName
	}).(pulumi.StringPtrOutput)
}

// Specifies the output format of the exposed resources, defaults to "1"
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) Divisor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return v.Divisor
	}).(pulumi.StringPtrOutput)
}

// Required: resource to select
func (o IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput) Resource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef) *string {
		if v == nil {
			return nil
		}
		return &v.Resource
	}).(pulumi.StringPtrOutput)
}

// information about the secret data to project
type IndexerClusterSpecVolumesProjectedSourcesSecret struct {
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []IndexerClusterSpecVolumesProjectedSourcesSecretItems `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
	// Specify whether the Secret or its key must be defined
	Optional *bool `pulumi:"optional"`
}

// IndexerClusterSpecVolumesProjectedSourcesSecretInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesSecretArgs and IndexerClusterSpecVolumesProjectedSourcesSecretOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesSecretInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesSecretArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesSecretInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesSecretOutput() IndexerClusterSpecVolumesProjectedSourcesSecretOutput
	ToIndexerClusterSpecVolumesProjectedSourcesSecretOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretOutput
}

// information about the secret data to project
type IndexerClusterSpecVolumesProjectedSourcesSecretArgs struct {
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayInput `pulumi:"items"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specify whether the Secret or its key must be defined
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (IndexerClusterSpecVolumesProjectedSourcesSecretArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesSecret)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretOutput() IndexerClusterSpecVolumesProjectedSourcesSecretOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesSecretOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesSecretOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesSecretOutput).ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesSecretPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesSecretArgs, IndexerClusterSpecVolumesProjectedSourcesSecretPtr and IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesSecretPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesSecretArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesSecretPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesSecretPtrType IndexerClusterSpecVolumesProjectedSourcesSecretArgs

func IndexerClusterSpecVolumesProjectedSourcesSecretPtr(v *IndexerClusterSpecVolumesProjectedSourcesSecretArgs) IndexerClusterSpecVolumesProjectedSourcesSecretPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesSecretPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesSecretPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesSecret)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesSecretPtrType) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesSecretPtrType) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput)
}

// information about the secret data to project
type IndexerClusterSpecVolumesProjectedSourcesSecretOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesSecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesSecret)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretOutput() IndexerClusterSpecVolumesProjectedSourcesSecretOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecret) *IndexerClusterSpecVolumesProjectedSourcesSecret {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) Items() IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecret) []IndexerClusterSpecVolumesProjectedSourcesSecretItems {
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecret) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specify whether the Secret or its key must be defined
func (o IndexerClusterSpecVolumesProjectedSourcesSecretOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecret) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesSecret)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput() IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesSecretOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesSecret) IndexerClusterSpecVolumesProjectedSourcesSecret {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) Items() IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesSecret) []IndexerClusterSpecVolumesProjectedSourcesSecretItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesSecret) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specify whether the Secret or its key must be defined
func (o IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesSecret) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesSecretItems struct {
	// The key to project.
	Key string `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path string `pulumi:"path"`
}

// IndexerClusterSpecVolumesProjectedSourcesSecretItemsInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs and IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesSecretItemsInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesSecretItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput
	ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs struct {
	// The key to project.
	Key pulumi.StringInput `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesSecretItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput)
}

// IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray and IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray{ IndexerClusterSpecVolumesProjectedSourcesSecretItemsArgs{...} }
type IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput
	ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput
}

type IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray []IndexerClusterSpecVolumesProjectedSourcesSecretItemsInput

func (IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesSecretItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesSecretItemsArray) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesSecretItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput {
	return o
}

// The key to project.
func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecretItems) string { return v.Key }).(pulumi.StringOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecretItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesSecretItems) string { return v.Path }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesProjectedSourcesSecretItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput() IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput) ToIndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesProjectedSourcesSecretItems {
		return vs[0].([]IndexerClusterSpecVolumesProjectedSourcesSecretItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput)
}

// information about the serviceAccountToken data to project
type IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken struct {
	// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
	Audience *string `pulumi:"audience"`
	// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
	ExpirationSeconds *int `pulumi:"expirationSeconds"`
	// Path is the path relative to the mount point of the file to project the token into.
	Path string `pulumi:"path"`
}

// IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs and IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs{...}
type IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput
	ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput
}

// information about the serviceAccountToken data to project
type IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs struct {
	// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
	Audience pulumi.StringPtrInput `pulumi:"audience"`
	// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
	ExpirationSeconds pulumi.IntPtrInput `pulumi:"expirationSeconds"`
	// Path is the path relative to the mount point of the file to project the token into.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput)
}

func (i IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput).ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrInput is an input type that accepts IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs, IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtr and IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrInput` via:
//
//          IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput
	ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput
}

type indexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrType IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs

func IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtr(v *IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenArgs) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrInput {
	return (*indexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrType)(v)
}

func (*indexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrType) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return i.ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrType) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput)
}

// information about the serviceAccountToken data to project
type IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return o.ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken {
		return &v
	}).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput)
}

// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) Audience() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *string { return v.Audience }).(pulumi.StringPtrOutput)
}

// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) ExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *int { return v.ExpirationSeconds }).(pulumi.IntPtrOutput)
}

// Path is the path relative to the mount point of the file to project the token into.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) string { return v.Path }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) ToIndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) Elem() IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken {
		return *v
	}).(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput)
}

// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) Audience() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *string {
		if v == nil {
			return nil
		}
		return v.Audience
	}).(pulumi.StringPtrOutput)
}

// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) ExpirationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *int {
		if v == nil {
			return nil
		}
		return v.ExpirationSeconds
	}).(pulumi.IntPtrOutput)
}

// Path is the path relative to the mount point of the file to project the token into.
func (o IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesProjectedSourcesServiceAccountToken) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesQuobyte struct {
	// Group to map volume access to Default is no group
	Group *string `pulumi:"group"`
	// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
	ReadOnly *bool `pulumi:"readOnly"`
	// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
	Registry string `pulumi:"registry"`
	// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
	Tenant *string `pulumi:"tenant"`
	// User to map volume access to Defaults to serivceaccount user
	User *string `pulumi:"user"`
	// Volume is a string that references an already created Quobyte volume by name.
	Volume string `pulumi:"volume"`
}

// IndexerClusterSpecVolumesQuobyteInput is an input type that accepts IndexerClusterSpecVolumesQuobyteArgs and IndexerClusterSpecVolumesQuobyteOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesQuobyteInput` via:
//
//          IndexerClusterSpecVolumesQuobyteArgs{...}
type IndexerClusterSpecVolumesQuobyteInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesQuobyteOutput() IndexerClusterSpecVolumesQuobyteOutput
	ToIndexerClusterSpecVolumesQuobyteOutputWithContext(context.Context) IndexerClusterSpecVolumesQuobyteOutput
}

// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesQuobyteArgs struct {
	// Group to map volume access to Default is no group
	Group pulumi.StringPtrInput `pulumi:"group"`
	// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
	Registry pulumi.StringInput `pulumi:"registry"`
	// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
	Tenant pulumi.StringPtrInput `pulumi:"tenant"`
	// User to map volume access to Defaults to serivceaccount user
	User pulumi.StringPtrInput `pulumi:"user"`
	// Volume is a string that references an already created Quobyte volume by name.
	Volume pulumi.StringInput `pulumi:"volume"`
}

func (IndexerClusterSpecVolumesQuobyteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesQuobyte)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesQuobyteArgs) ToIndexerClusterSpecVolumesQuobyteOutput() IndexerClusterSpecVolumesQuobyteOutput {
	return i.ToIndexerClusterSpecVolumesQuobyteOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesQuobyteArgs) ToIndexerClusterSpecVolumesQuobyteOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobyteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesQuobyteOutput)
}

func (i IndexerClusterSpecVolumesQuobyteArgs) ToIndexerClusterSpecVolumesQuobytePtrOutput() IndexerClusterSpecVolumesQuobytePtrOutput {
	return i.ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesQuobyteArgs) ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobytePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesQuobyteOutput).ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesQuobytePtrInput is an input type that accepts IndexerClusterSpecVolumesQuobyteArgs, IndexerClusterSpecVolumesQuobytePtr and IndexerClusterSpecVolumesQuobytePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesQuobytePtrInput` via:
//
//          IndexerClusterSpecVolumesQuobyteArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesQuobytePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesQuobytePtrOutput() IndexerClusterSpecVolumesQuobytePtrOutput
	ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesQuobytePtrOutput
}

type indexerClusterSpecVolumesQuobytePtrType IndexerClusterSpecVolumesQuobyteArgs

func IndexerClusterSpecVolumesQuobytePtr(v *IndexerClusterSpecVolumesQuobyteArgs) IndexerClusterSpecVolumesQuobytePtrInput {
	return (*indexerClusterSpecVolumesQuobytePtrType)(v)
}

func (*indexerClusterSpecVolumesQuobytePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesQuobyte)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesQuobytePtrType) ToIndexerClusterSpecVolumesQuobytePtrOutput() IndexerClusterSpecVolumesQuobytePtrOutput {
	return i.ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesQuobytePtrType) ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobytePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesQuobytePtrOutput)
}

// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
type IndexerClusterSpecVolumesQuobyteOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesQuobyteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesQuobyte)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesQuobyteOutput) ToIndexerClusterSpecVolumesQuobyteOutput() IndexerClusterSpecVolumesQuobyteOutput {
	return o
}

func (o IndexerClusterSpecVolumesQuobyteOutput) ToIndexerClusterSpecVolumesQuobyteOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobyteOutput {
	return o
}

func (o IndexerClusterSpecVolumesQuobyteOutput) ToIndexerClusterSpecVolumesQuobytePtrOutput() IndexerClusterSpecVolumesQuobytePtrOutput {
	return o.ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesQuobyteOutput) ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobytePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) *IndexerClusterSpecVolumesQuobyte {
		return &v
	}).(IndexerClusterSpecVolumesQuobytePtrOutput)
}

// Group to map volume access to Default is no group
func (o IndexerClusterSpecVolumesQuobyteOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
func (o IndexerClusterSpecVolumesQuobyteOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
func (o IndexerClusterSpecVolumesQuobyteOutput) Registry() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) string { return v.Registry }).(pulumi.StringOutput)
}

// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
func (o IndexerClusterSpecVolumesQuobyteOutput) Tenant() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) *string { return v.Tenant }).(pulumi.StringPtrOutput)
}

// User to map volume access to Defaults to serivceaccount user
func (o IndexerClusterSpecVolumesQuobyteOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) *string { return v.User }).(pulumi.StringPtrOutput)
}

// Volume is a string that references an already created Quobyte volume by name.
func (o IndexerClusterSpecVolumesQuobyteOutput) Volume() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesQuobyte) string { return v.Volume }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesQuobytePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesQuobytePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesQuobyte)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesQuobytePtrOutput) ToIndexerClusterSpecVolumesQuobytePtrOutput() IndexerClusterSpecVolumesQuobytePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesQuobytePtrOutput) ToIndexerClusterSpecVolumesQuobytePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesQuobytePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesQuobytePtrOutput) Elem() IndexerClusterSpecVolumesQuobyteOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) IndexerClusterSpecVolumesQuobyte { return *v }).(IndexerClusterSpecVolumesQuobyteOutput)
}

// Group to map volume access to Default is no group
func (o IndexerClusterSpecVolumesQuobytePtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
func (o IndexerClusterSpecVolumesQuobytePtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
func (o IndexerClusterSpecVolumesQuobytePtrOutput) Registry() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *string {
		if v == nil {
			return nil
		}
		return &v.Registry
	}).(pulumi.StringPtrOutput)
}

// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
func (o IndexerClusterSpecVolumesQuobytePtrOutput) Tenant() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *string {
		if v == nil {
			return nil
		}
		return v.Tenant
	}).(pulumi.StringPtrOutput)
}

// User to map volume access to Defaults to serivceaccount user
func (o IndexerClusterSpecVolumesQuobytePtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// Volume is a string that references an already created Quobyte volume by name.
func (o IndexerClusterSpecVolumesQuobytePtrOutput) Volume() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesQuobyte) *string {
		if v == nil {
			return nil
		}
		return &v.Volume
	}).(pulumi.StringPtrOutput)
}

// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
type IndexerClusterSpecVolumesRbd struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType *string `pulumi:"fsType"`
	// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Image string `pulumi:"image"`
	// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Keyring *string `pulumi:"keyring"`
	// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Monitors []string `pulumi:"monitors"`
	// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Pool *string `pulumi:"pool"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	ReadOnly *bool `pulumi:"readOnly"`
	// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	SecretRef *IndexerClusterSpecVolumesRbdSecretRef `pulumi:"secretRef"`
	// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	User *string `pulumi:"user"`
}

// IndexerClusterSpecVolumesRbdInput is an input type that accepts IndexerClusterSpecVolumesRbdArgs and IndexerClusterSpecVolumesRbdOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesRbdInput` via:
//
//          IndexerClusterSpecVolumesRbdArgs{...}
type IndexerClusterSpecVolumesRbdInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesRbdOutput() IndexerClusterSpecVolumesRbdOutput
	ToIndexerClusterSpecVolumesRbdOutputWithContext(context.Context) IndexerClusterSpecVolumesRbdOutput
}

// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
type IndexerClusterSpecVolumesRbdArgs struct {
	// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Image pulumi.StringInput `pulumi:"image"`
	// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Keyring pulumi.StringPtrInput `pulumi:"keyring"`
	// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Monitors pulumi.StringArrayInput `pulumi:"monitors"`
	// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	Pool pulumi.StringPtrInput `pulumi:"pool"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	SecretRef IndexerClusterSpecVolumesRbdSecretRefPtrInput `pulumi:"secretRef"`
	// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	User pulumi.StringPtrInput `pulumi:"user"`
}

func (IndexerClusterSpecVolumesRbdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesRbd)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesRbdArgs) ToIndexerClusterSpecVolumesRbdOutput() IndexerClusterSpecVolumesRbdOutput {
	return i.ToIndexerClusterSpecVolumesRbdOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesRbdArgs) ToIndexerClusterSpecVolumesRbdOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdOutput)
}

func (i IndexerClusterSpecVolumesRbdArgs) ToIndexerClusterSpecVolumesRbdPtrOutput() IndexerClusterSpecVolumesRbdPtrOutput {
	return i.ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesRbdArgs) ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdOutput).ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesRbdPtrInput is an input type that accepts IndexerClusterSpecVolumesRbdArgs, IndexerClusterSpecVolumesRbdPtr and IndexerClusterSpecVolumesRbdPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesRbdPtrInput` via:
//
//          IndexerClusterSpecVolumesRbdArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesRbdPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesRbdPtrOutput() IndexerClusterSpecVolumesRbdPtrOutput
	ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesRbdPtrOutput
}

type indexerClusterSpecVolumesRbdPtrType IndexerClusterSpecVolumesRbdArgs

func IndexerClusterSpecVolumesRbdPtr(v *IndexerClusterSpecVolumesRbdArgs) IndexerClusterSpecVolumesRbdPtrInput {
	return (*indexerClusterSpecVolumesRbdPtrType)(v)
}

func (*indexerClusterSpecVolumesRbdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesRbd)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesRbdPtrType) ToIndexerClusterSpecVolumesRbdPtrOutput() IndexerClusterSpecVolumesRbdPtrOutput {
	return i.ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesRbdPtrType) ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdPtrOutput)
}

// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
type IndexerClusterSpecVolumesRbdOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesRbdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesRbd)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesRbdOutput) ToIndexerClusterSpecVolumesRbdOutput() IndexerClusterSpecVolumesRbdOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdOutput) ToIndexerClusterSpecVolumesRbdOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdOutput) ToIndexerClusterSpecVolumesRbdPtrOutput() IndexerClusterSpecVolumesRbdPtrOutput {
	return o.ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesRbdOutput) ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *IndexerClusterSpecVolumesRbd {
		return &v
	}).(IndexerClusterSpecVolumesRbdPtrOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesRbdOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) Image() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) string { return v.Image }).(pulumi.StringOutput)
}

// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) Keyring() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *string { return v.Keyring }).(pulumi.StringPtrOutput)
}

// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) Monitors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) []string { return v.Monitors }).(pulumi.StringArrayOutput)
}

// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *string { return v.Pool }).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) SecretRef() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *IndexerClusterSpecVolumesRbdSecretRef { return v.SecretRef }).(IndexerClusterSpecVolumesRbdSecretRefPtrOutput)
}

// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbd) *string { return v.User }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesRbdPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesRbdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesRbd)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesRbdPtrOutput) ToIndexerClusterSpecVolumesRbdPtrOutput() IndexerClusterSpecVolumesRbdPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdPtrOutput) ToIndexerClusterSpecVolumesRbdPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdPtrOutput) Elem() IndexerClusterSpecVolumesRbdOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) IndexerClusterSpecVolumesRbd { return *v }).(IndexerClusterSpecVolumesRbdOutput)
}

// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
func (o IndexerClusterSpecVolumesRbdPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *string {
		if v == nil {
			return nil
		}
		return &v.Image
	}).(pulumi.StringPtrOutput)
}

// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) Keyring() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *string {
		if v == nil {
			return nil
		}
		return v.Keyring
	}).(pulumi.StringPtrOutput)
}

// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) Monitors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) []string {
		if v == nil {
			return nil
		}
		return v.Monitors
	}).(pulumi.StringArrayOutput)
}

// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) Pool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *string {
		if v == nil {
			return nil
		}
		return v.Pool
	}).(pulumi.StringPtrOutput)
}

// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) SecretRef() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *IndexerClusterSpecVolumesRbdSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesRbdSecretRefPtrOutput)
}

// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
func (o IndexerClusterSpecVolumesRbdPtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbd) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
type IndexerClusterSpecVolumesRbdSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesRbdSecretRefInput is an input type that accepts IndexerClusterSpecVolumesRbdSecretRefArgs and IndexerClusterSpecVolumesRbdSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesRbdSecretRefInput` via:
//
//          IndexerClusterSpecVolumesRbdSecretRefArgs{...}
type IndexerClusterSpecVolumesRbdSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesRbdSecretRefOutput() IndexerClusterSpecVolumesRbdSecretRefOutput
	ToIndexerClusterSpecVolumesRbdSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesRbdSecretRefOutput
}

// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
type IndexerClusterSpecVolumesRbdSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesRbdSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesRbdSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesRbdSecretRefArgs) ToIndexerClusterSpecVolumesRbdSecretRefOutput() IndexerClusterSpecVolumesRbdSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesRbdSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesRbdSecretRefArgs) ToIndexerClusterSpecVolumesRbdSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdSecretRefOutput)
}

func (i IndexerClusterSpecVolumesRbdSecretRefArgs) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutput() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesRbdSecretRefArgs) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdSecretRefOutput).ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesRbdSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesRbdSecretRefArgs, IndexerClusterSpecVolumesRbdSecretRefPtr and IndexerClusterSpecVolumesRbdSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesRbdSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesRbdSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesRbdSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesRbdSecretRefPtrOutput() IndexerClusterSpecVolumesRbdSecretRefPtrOutput
	ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesRbdSecretRefPtrOutput
}

type indexerClusterSpecVolumesRbdSecretRefPtrType IndexerClusterSpecVolumesRbdSecretRefArgs

func IndexerClusterSpecVolumesRbdSecretRefPtr(v *IndexerClusterSpecVolumesRbdSecretRefArgs) IndexerClusterSpecVolumesRbdSecretRefPtrInput {
	return (*indexerClusterSpecVolumesRbdSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesRbdSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesRbdSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesRbdSecretRefPtrType) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutput() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesRbdSecretRefPtrType) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesRbdSecretRefPtrOutput)
}

// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
type IndexerClusterSpecVolumesRbdSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesRbdSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesRbdSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesRbdSecretRefOutput) ToIndexerClusterSpecVolumesRbdSecretRefOutput() IndexerClusterSpecVolumesRbdSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdSecretRefOutput) ToIndexerClusterSpecVolumesRbdSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdSecretRefOutput) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutput() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesRbdSecretRefOutput) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbdSecretRef) *IndexerClusterSpecVolumesRbdSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesRbdSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesRbdSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesRbdSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesRbdSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesRbdSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesRbdSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesRbdSecretRefPtrOutput) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutput() IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdSecretRefPtrOutput) ToIndexerClusterSpecVolumesRbdSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesRbdSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesRbdSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesRbdSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbdSecretRef) IndexerClusterSpecVolumesRbdSecretRef { return *v }).(IndexerClusterSpecVolumesRbdSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesRbdSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesRbdSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesScaleIO struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
	FsType *string `pulumi:"fsType"`
	// The host address of the ScaleIO API Gateway.
	Gateway string `pulumi:"gateway"`
	// The name of the ScaleIO Protection Domain for the configured storage.
	ProtectionDomain *string `pulumi:"protectionDomain"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
	SecretRef IndexerClusterSpecVolumesScaleIOSecretRef `pulumi:"secretRef"`
	// Flag to enable/disable SSL communication with Gateway, default false
	SslEnabled *bool `pulumi:"sslEnabled"`
	// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
	StorageMode *string `pulumi:"storageMode"`
	// The ScaleIO Storage Pool associated with the protection domain.
	StoragePool *string `pulumi:"storagePool"`
	// The name of the storage system as configured in ScaleIO.
	System string `pulumi:"system"`
	// The name of a volume already created in the ScaleIO system that is associated with this volume source.
	VolumeName *string `pulumi:"volumeName"`
}

// IndexerClusterSpecVolumesScaleIOInput is an input type that accepts IndexerClusterSpecVolumesScaleIOArgs and IndexerClusterSpecVolumesScaleIOOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesScaleIOInput` via:
//
//          IndexerClusterSpecVolumesScaleIOArgs{...}
type IndexerClusterSpecVolumesScaleIOInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesScaleIOOutput() IndexerClusterSpecVolumesScaleIOOutput
	ToIndexerClusterSpecVolumesScaleIOOutputWithContext(context.Context) IndexerClusterSpecVolumesScaleIOOutput
}

// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesScaleIOArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// The host address of the ScaleIO API Gateway.
	Gateway pulumi.StringInput `pulumi:"gateway"`
	// The name of the ScaleIO Protection Domain for the configured storage.
	ProtectionDomain pulumi.StringPtrInput `pulumi:"protectionDomain"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
	SecretRef IndexerClusterSpecVolumesScaleIOSecretRefInput `pulumi:"secretRef"`
	// Flag to enable/disable SSL communication with Gateway, default false
	SslEnabled pulumi.BoolPtrInput `pulumi:"sslEnabled"`
	// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
	StorageMode pulumi.StringPtrInput `pulumi:"storageMode"`
	// The ScaleIO Storage Pool associated with the protection domain.
	StoragePool pulumi.StringPtrInput `pulumi:"storagePool"`
	// The name of the storage system as configured in ScaleIO.
	System pulumi.StringInput `pulumi:"system"`
	// The name of a volume already created in the ScaleIO system that is associated with this volume source.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
}

func (IndexerClusterSpecVolumesScaleIOArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesScaleIO)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesScaleIOArgs) ToIndexerClusterSpecVolumesScaleIOOutput() IndexerClusterSpecVolumesScaleIOOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesScaleIOArgs) ToIndexerClusterSpecVolumesScaleIOOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOOutput)
}

func (i IndexerClusterSpecVolumesScaleIOArgs) ToIndexerClusterSpecVolumesScaleIOPtrOutput() IndexerClusterSpecVolumesScaleIOPtrOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesScaleIOArgs) ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOOutput).ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesScaleIOPtrInput is an input type that accepts IndexerClusterSpecVolumesScaleIOArgs, IndexerClusterSpecVolumesScaleIOPtr and IndexerClusterSpecVolumesScaleIOPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesScaleIOPtrInput` via:
//
//          IndexerClusterSpecVolumesScaleIOArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesScaleIOPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesScaleIOPtrOutput() IndexerClusterSpecVolumesScaleIOPtrOutput
	ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesScaleIOPtrOutput
}

type indexerClusterSpecVolumesScaleIOPtrType IndexerClusterSpecVolumesScaleIOArgs

func IndexerClusterSpecVolumesScaleIOPtr(v *IndexerClusterSpecVolumesScaleIOArgs) IndexerClusterSpecVolumesScaleIOPtrInput {
	return (*indexerClusterSpecVolumesScaleIOPtrType)(v)
}

func (*indexerClusterSpecVolumesScaleIOPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesScaleIO)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesScaleIOPtrType) ToIndexerClusterSpecVolumesScaleIOPtrOutput() IndexerClusterSpecVolumesScaleIOPtrOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesScaleIOPtrType) ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOPtrOutput)
}

// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesScaleIOOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesScaleIOOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesScaleIO)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesScaleIOOutput) ToIndexerClusterSpecVolumesScaleIOOutput() IndexerClusterSpecVolumesScaleIOOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOOutput) ToIndexerClusterSpecVolumesScaleIOOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOOutput) ToIndexerClusterSpecVolumesScaleIOPtrOutput() IndexerClusterSpecVolumesScaleIOPtrOutput {
	return o.ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesScaleIOOutput) ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *IndexerClusterSpecVolumesScaleIO {
		return &v
	}).(IndexerClusterSpecVolumesScaleIOPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
func (o IndexerClusterSpecVolumesScaleIOOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// The host address of the ScaleIO API Gateway.
func (o IndexerClusterSpecVolumesScaleIOOutput) Gateway() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) string { return v.Gateway }).(pulumi.StringOutput)
}

// The name of the ScaleIO Protection Domain for the configured storage.
func (o IndexerClusterSpecVolumesScaleIOOutput) ProtectionDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *string { return v.ProtectionDomain }).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesScaleIOOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
func (o IndexerClusterSpecVolumesScaleIOOutput) SecretRef() IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) IndexerClusterSpecVolumesScaleIOSecretRef { return v.SecretRef }).(IndexerClusterSpecVolumesScaleIOSecretRefOutput)
}

// Flag to enable/disable SSL communication with Gateway, default false
func (o IndexerClusterSpecVolumesScaleIOOutput) SslEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *bool { return v.SslEnabled }).(pulumi.BoolPtrOutput)
}

// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
func (o IndexerClusterSpecVolumesScaleIOOutput) StorageMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *string { return v.StorageMode }).(pulumi.StringPtrOutput)
}

// The ScaleIO Storage Pool associated with the protection domain.
func (o IndexerClusterSpecVolumesScaleIOOutput) StoragePool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *string { return v.StoragePool }).(pulumi.StringPtrOutput)
}

// The name of the storage system as configured in ScaleIO.
func (o IndexerClusterSpecVolumesScaleIOOutput) System() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) string { return v.System }).(pulumi.StringOutput)
}

// The name of a volume already created in the ScaleIO system that is associated with this volume source.
func (o IndexerClusterSpecVolumesScaleIOOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIO) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesScaleIOPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesScaleIOPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesScaleIO)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesScaleIOPtrOutput) ToIndexerClusterSpecVolumesScaleIOPtrOutput() IndexerClusterSpecVolumesScaleIOPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOPtrOutput) ToIndexerClusterSpecVolumesScaleIOPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOPtrOutput) Elem() IndexerClusterSpecVolumesScaleIOOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) IndexerClusterSpecVolumesScaleIO { return *v }).(IndexerClusterSpecVolumesScaleIOOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// The host address of the ScaleIO API Gateway.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) Gateway() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return &v.Gateway
	}).(pulumi.StringPtrOutput)
}

// The name of the ScaleIO Protection Domain for the configured storage.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) ProtectionDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return v.ProtectionDomain
	}).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) SecretRef() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *IndexerClusterSpecVolumesScaleIOSecretRef {
		if v == nil {
			return nil
		}
		return &v.SecretRef
	}).(IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput)
}

// Flag to enable/disable SSL communication with Gateway, default false
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) SslEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *bool {
		if v == nil {
			return nil
		}
		return v.SslEnabled
	}).(pulumi.BoolPtrOutput)
}

// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) StorageMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return v.StorageMode
	}).(pulumi.StringPtrOutput)
}

// The ScaleIO Storage Pool associated with the protection domain.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) StoragePool() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return v.StoragePool
	}).(pulumi.StringPtrOutput)
}

// The name of the storage system as configured in ScaleIO.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) System() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return &v.System
	}).(pulumi.StringPtrOutput)
}

// The name of a volume already created in the ScaleIO system that is associated with this volume source.
func (o IndexerClusterSpecVolumesScaleIOPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIO) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
type IndexerClusterSpecVolumesScaleIOSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesScaleIOSecretRefInput is an input type that accepts IndexerClusterSpecVolumesScaleIOSecretRefArgs and IndexerClusterSpecVolumesScaleIOSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesScaleIOSecretRefInput` via:
//
//          IndexerClusterSpecVolumesScaleIOSecretRefArgs{...}
type IndexerClusterSpecVolumesScaleIOSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesScaleIOSecretRefOutput() IndexerClusterSpecVolumesScaleIOSecretRefOutput
	ToIndexerClusterSpecVolumesScaleIOSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesScaleIOSecretRefOutput
}

// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
type IndexerClusterSpecVolumesScaleIOSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesScaleIOSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesScaleIOSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesScaleIOSecretRefArgs) ToIndexerClusterSpecVolumesScaleIOSecretRefOutput() IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesScaleIOSecretRefArgs) ToIndexerClusterSpecVolumesScaleIOSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOSecretRefOutput)
}

func (i IndexerClusterSpecVolumesScaleIOSecretRefArgs) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutput() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesScaleIOSecretRefArgs) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOSecretRefOutput).ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesScaleIOSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesScaleIOSecretRefArgs, IndexerClusterSpecVolumesScaleIOSecretRefPtr and IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesScaleIOSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesScaleIOSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesScaleIOSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutput() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput
	ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput
}

type indexerClusterSpecVolumesScaleIOSecretRefPtrType IndexerClusterSpecVolumesScaleIOSecretRefArgs

func IndexerClusterSpecVolumesScaleIOSecretRefPtr(v *IndexerClusterSpecVolumesScaleIOSecretRefArgs) IndexerClusterSpecVolumesScaleIOSecretRefPtrInput {
	return (*indexerClusterSpecVolumesScaleIOSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesScaleIOSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesScaleIOSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesScaleIOSecretRefPtrType) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutput() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesScaleIOSecretRefPtrType) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput)
}

// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
type IndexerClusterSpecVolumesScaleIOSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesScaleIOSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesScaleIOSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefOutput() IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutput() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIOSecretRef) *IndexerClusterSpecVolumesScaleIOSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesScaleIOSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesScaleIOSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesScaleIOSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutput() IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput) ToIndexerClusterSpecVolumesScaleIOSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesScaleIOSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIOSecretRef) IndexerClusterSpecVolumesScaleIOSecretRef {
		return *v
	}).(IndexerClusterSpecVolumesScaleIOSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesScaleIOSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
type IndexerClusterSpecVolumesSecret struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items []IndexerClusterSpecVolumesSecretItems `pulumi:"items"`
	// Specify whether the Secret or its keys must be defined
	Optional *bool `pulumi:"optional"`
	// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	SecretName *string `pulumi:"secretName"`
}

// IndexerClusterSpecVolumesSecretInput is an input type that accepts IndexerClusterSpecVolumesSecretArgs and IndexerClusterSpecVolumesSecretOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesSecretInput` via:
//
//          IndexerClusterSpecVolumesSecretArgs{...}
type IndexerClusterSpecVolumesSecretInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesSecretOutput() IndexerClusterSpecVolumesSecretOutput
	ToIndexerClusterSpecVolumesSecretOutputWithContext(context.Context) IndexerClusterSpecVolumesSecretOutput
}

// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
type IndexerClusterSpecVolumesSecretArgs struct {
	// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
	Items IndexerClusterSpecVolumesSecretItemsArrayInput `pulumi:"items"`
	// Specify whether the Secret or its keys must be defined
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
	// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (IndexerClusterSpecVolumesSecretArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesSecret)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesSecretArgs) ToIndexerClusterSpecVolumesSecretOutput() IndexerClusterSpecVolumesSecretOutput {
	return i.ToIndexerClusterSpecVolumesSecretOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesSecretArgs) ToIndexerClusterSpecVolumesSecretOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesSecretOutput)
}

func (i IndexerClusterSpecVolumesSecretArgs) ToIndexerClusterSpecVolumesSecretPtrOutput() IndexerClusterSpecVolumesSecretPtrOutput {
	return i.ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesSecretArgs) ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesSecretOutput).ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesSecretPtrInput is an input type that accepts IndexerClusterSpecVolumesSecretArgs, IndexerClusterSpecVolumesSecretPtr and IndexerClusterSpecVolumesSecretPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesSecretPtrInput` via:
//
//          IndexerClusterSpecVolumesSecretArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesSecretPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesSecretPtrOutput() IndexerClusterSpecVolumesSecretPtrOutput
	ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesSecretPtrOutput
}

type indexerClusterSpecVolumesSecretPtrType IndexerClusterSpecVolumesSecretArgs

func IndexerClusterSpecVolumesSecretPtr(v *IndexerClusterSpecVolumesSecretArgs) IndexerClusterSpecVolumesSecretPtrInput {
	return (*indexerClusterSpecVolumesSecretPtrType)(v)
}

func (*indexerClusterSpecVolumesSecretPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesSecret)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesSecretPtrType) ToIndexerClusterSpecVolumesSecretPtrOutput() IndexerClusterSpecVolumesSecretPtrOutput {
	return i.ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesSecretPtrType) ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesSecretPtrOutput)
}

// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
type IndexerClusterSpecVolumesSecretOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesSecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesSecret)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesSecretOutput) ToIndexerClusterSpecVolumesSecretOutput() IndexerClusterSpecVolumesSecretOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretOutput) ToIndexerClusterSpecVolumesSecretOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretOutput) ToIndexerClusterSpecVolumesSecretPtrOutput() IndexerClusterSpecVolumesSecretPtrOutput {
	return o.ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesSecretOutput) ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecret) *IndexerClusterSpecVolumesSecret {
		return &v
	}).(IndexerClusterSpecVolumesSecretPtrOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesSecretOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecret) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesSecretOutput) Items() IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecret) []IndexerClusterSpecVolumesSecretItems { return v.Items }).(IndexerClusterSpecVolumesSecretItemsArrayOutput)
}

// Specify whether the Secret or its keys must be defined
func (o IndexerClusterSpecVolumesSecretOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecret) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
func (o IndexerClusterSpecVolumesSecretOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecret) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesSecretPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesSecretPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesSecret)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesSecretPtrOutput) ToIndexerClusterSpecVolumesSecretPtrOutput() IndexerClusterSpecVolumesSecretPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretPtrOutput) ToIndexerClusterSpecVolumesSecretPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretPtrOutput) Elem() IndexerClusterSpecVolumesSecretOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesSecret) IndexerClusterSpecVolumesSecret { return *v }).(IndexerClusterSpecVolumesSecretOutput)
}

// Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesSecretPtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesSecret) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
func (o IndexerClusterSpecVolumesSecretPtrOutput) Items() IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesSecret) []IndexerClusterSpecVolumesSecretItems {
		if v == nil {
			return nil
		}
		return v.Items
	}).(IndexerClusterSpecVolumesSecretItemsArrayOutput)
}

// Specify whether the Secret or its keys must be defined
func (o IndexerClusterSpecVolumesSecretPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesSecret) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
func (o IndexerClusterSpecVolumesSecretPtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesSecret) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesSecretItems struct {
	// The key to project.
	Key string `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode *int `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path string `pulumi:"path"`
}

// IndexerClusterSpecVolumesSecretItemsInput is an input type that accepts IndexerClusterSpecVolumesSecretItemsArgs and IndexerClusterSpecVolumesSecretItemsOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesSecretItemsInput` via:
//
//          IndexerClusterSpecVolumesSecretItemsArgs{...}
type IndexerClusterSpecVolumesSecretItemsInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesSecretItemsOutput() IndexerClusterSpecVolumesSecretItemsOutput
	ToIndexerClusterSpecVolumesSecretItemsOutputWithContext(context.Context) IndexerClusterSpecVolumesSecretItemsOutput
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesSecretItemsArgs struct {
	// The key to project.
	Key pulumi.StringInput `pulumi:"key"`
	// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IndexerClusterSpecVolumesSecretItemsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesSecretItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesSecretItemsArgs) ToIndexerClusterSpecVolumesSecretItemsOutput() IndexerClusterSpecVolumesSecretItemsOutput {
	return i.ToIndexerClusterSpecVolumesSecretItemsOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesSecretItemsArgs) ToIndexerClusterSpecVolumesSecretItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretItemsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesSecretItemsOutput)
}

// IndexerClusterSpecVolumesSecretItemsArrayInput is an input type that accepts IndexerClusterSpecVolumesSecretItemsArray and IndexerClusterSpecVolumesSecretItemsArrayOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesSecretItemsArrayInput` via:
//
//          IndexerClusterSpecVolumesSecretItemsArray{ IndexerClusterSpecVolumesSecretItemsArgs{...} }
type IndexerClusterSpecVolumesSecretItemsArrayInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesSecretItemsArrayOutput() IndexerClusterSpecVolumesSecretItemsArrayOutput
	ToIndexerClusterSpecVolumesSecretItemsArrayOutputWithContext(context.Context) IndexerClusterSpecVolumesSecretItemsArrayOutput
}

type IndexerClusterSpecVolumesSecretItemsArray []IndexerClusterSpecVolumesSecretItemsInput

func (IndexerClusterSpecVolumesSecretItemsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesSecretItems)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesSecretItemsArray) ToIndexerClusterSpecVolumesSecretItemsArrayOutput() IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return i.ToIndexerClusterSpecVolumesSecretItemsArrayOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesSecretItemsArray) ToIndexerClusterSpecVolumesSecretItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesSecretItemsArrayOutput)
}

// Maps a string key to a path within a volume.
type IndexerClusterSpecVolumesSecretItemsOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesSecretItemsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesSecretItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesSecretItemsOutput) ToIndexerClusterSpecVolumesSecretItemsOutput() IndexerClusterSpecVolumesSecretItemsOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretItemsOutput) ToIndexerClusterSpecVolumesSecretItemsOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretItemsOutput {
	return o
}

// The key to project.
func (o IndexerClusterSpecVolumesSecretItemsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecretItems) string { return v.Key }).(pulumi.StringOutput)
}

// Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o IndexerClusterSpecVolumesSecretItemsOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecretItems) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
func (o IndexerClusterSpecVolumesSecretItemsOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesSecretItems) string { return v.Path }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesSecretItemsArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesSecretItemsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterSpecVolumesSecretItems)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesSecretItemsArrayOutput) ToIndexerClusterSpecVolumesSecretItemsArrayOutput() IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretItemsArrayOutput) ToIndexerClusterSpecVolumesSecretItemsArrayOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesSecretItemsArrayOutput {
	return o
}

func (o IndexerClusterSpecVolumesSecretItemsArrayOutput) Index(i pulumi.IntInput) IndexerClusterSpecVolumesSecretItemsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterSpecVolumesSecretItems {
		return vs[0].([]IndexerClusterSpecVolumesSecretItems)[vs[1].(int)]
	}).(IndexerClusterSpecVolumesSecretItemsOutput)
}

// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesStorageos struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType *string `pulumi:"fsType"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly *bool `pulumi:"readOnly"`
	// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
	SecretRef *IndexerClusterSpecVolumesStorageosSecretRef `pulumi:"secretRef"`
	// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
	VolumeName *string `pulumi:"volumeName"`
	// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
	VolumeNamespace *string `pulumi:"volumeNamespace"`
}

// IndexerClusterSpecVolumesStorageosInput is an input type that accepts IndexerClusterSpecVolumesStorageosArgs and IndexerClusterSpecVolumesStorageosOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesStorageosInput` via:
//
//          IndexerClusterSpecVolumesStorageosArgs{...}
type IndexerClusterSpecVolumesStorageosInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesStorageosOutput() IndexerClusterSpecVolumesStorageosOutput
	ToIndexerClusterSpecVolumesStorageosOutputWithContext(context.Context) IndexerClusterSpecVolumesStorageosOutput
}

// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesStorageosArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
	SecretRef IndexerClusterSpecVolumesStorageosSecretRefPtrInput `pulumi:"secretRef"`
	// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
	VolumeName pulumi.StringPtrInput `pulumi:"volumeName"`
	// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
	VolumeNamespace pulumi.StringPtrInput `pulumi:"volumeNamespace"`
}

func (IndexerClusterSpecVolumesStorageosArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesStorageos)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesStorageosArgs) ToIndexerClusterSpecVolumesStorageosOutput() IndexerClusterSpecVolumesStorageosOutput {
	return i.ToIndexerClusterSpecVolumesStorageosOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesStorageosArgs) ToIndexerClusterSpecVolumesStorageosOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosOutput)
}

func (i IndexerClusterSpecVolumesStorageosArgs) ToIndexerClusterSpecVolumesStorageosPtrOutput() IndexerClusterSpecVolumesStorageosPtrOutput {
	return i.ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesStorageosArgs) ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosOutput).ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesStorageosPtrInput is an input type that accepts IndexerClusterSpecVolumesStorageosArgs, IndexerClusterSpecVolumesStorageosPtr and IndexerClusterSpecVolumesStorageosPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesStorageosPtrInput` via:
//
//          IndexerClusterSpecVolumesStorageosArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesStorageosPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesStorageosPtrOutput() IndexerClusterSpecVolumesStorageosPtrOutput
	ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesStorageosPtrOutput
}

type indexerClusterSpecVolumesStorageosPtrType IndexerClusterSpecVolumesStorageosArgs

func IndexerClusterSpecVolumesStorageosPtr(v *IndexerClusterSpecVolumesStorageosArgs) IndexerClusterSpecVolumesStorageosPtrInput {
	return (*indexerClusterSpecVolumesStorageosPtrType)(v)
}

func (*indexerClusterSpecVolumesStorageosPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesStorageos)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesStorageosPtrType) ToIndexerClusterSpecVolumesStorageosPtrOutput() IndexerClusterSpecVolumesStorageosPtrOutput {
	return i.ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesStorageosPtrType) ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosPtrOutput)
}

// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
type IndexerClusterSpecVolumesStorageosOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesStorageosOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesStorageos)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesStorageosOutput) ToIndexerClusterSpecVolumesStorageosOutput() IndexerClusterSpecVolumesStorageosOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosOutput) ToIndexerClusterSpecVolumesStorageosOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosOutput) ToIndexerClusterSpecVolumesStorageosPtrOutput() IndexerClusterSpecVolumesStorageosPtrOutput {
	return o.ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesStorageosOutput) ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *IndexerClusterSpecVolumesStorageos {
		return &v
	}).(IndexerClusterSpecVolumesStorageosPtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesStorageosOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesStorageosOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
func (o IndexerClusterSpecVolumesStorageosOutput) SecretRef() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *IndexerClusterSpecVolumesStorageosSecretRef {
		return v.SecretRef
	}).(IndexerClusterSpecVolumesStorageosSecretRefPtrOutput)
}

// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
func (o IndexerClusterSpecVolumesStorageosOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *string { return v.VolumeName }).(pulumi.StringPtrOutput)
}

// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
func (o IndexerClusterSpecVolumesStorageosOutput) VolumeNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageos) *string { return v.VolumeNamespace }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesStorageosPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesStorageosPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesStorageos)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesStorageosPtrOutput) ToIndexerClusterSpecVolumesStorageosPtrOutput() IndexerClusterSpecVolumesStorageosPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosPtrOutput) ToIndexerClusterSpecVolumesStorageosPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosPtrOutput) Elem() IndexerClusterSpecVolumesStorageosOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) IndexerClusterSpecVolumesStorageos { return *v }).(IndexerClusterSpecVolumesStorageosOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesStorageosPtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
func (o IndexerClusterSpecVolumesStorageosPtrOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnly
	}).(pulumi.BoolPtrOutput)
}

// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
func (o IndexerClusterSpecVolumesStorageosPtrOutput) SecretRef() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) *IndexerClusterSpecVolumesStorageosSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(IndexerClusterSpecVolumesStorageosSecretRefPtrOutput)
}

// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
func (o IndexerClusterSpecVolumesStorageosPtrOutput) VolumeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) *string {
		if v == nil {
			return nil
		}
		return v.VolumeName
	}).(pulumi.StringPtrOutput)
}

// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
func (o IndexerClusterSpecVolumesStorageosPtrOutput) VolumeNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageos) *string {
		if v == nil {
			return nil
		}
		return v.VolumeNamespace
	}).(pulumi.StringPtrOutput)
}

// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
type IndexerClusterSpecVolumesStorageosSecretRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// IndexerClusterSpecVolumesStorageosSecretRefInput is an input type that accepts IndexerClusterSpecVolumesStorageosSecretRefArgs and IndexerClusterSpecVolumesStorageosSecretRefOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesStorageosSecretRefInput` via:
//
//          IndexerClusterSpecVolumesStorageosSecretRefArgs{...}
type IndexerClusterSpecVolumesStorageosSecretRefInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesStorageosSecretRefOutput() IndexerClusterSpecVolumesStorageosSecretRefOutput
	ToIndexerClusterSpecVolumesStorageosSecretRefOutputWithContext(context.Context) IndexerClusterSpecVolumesStorageosSecretRefOutput
}

// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
type IndexerClusterSpecVolumesStorageosSecretRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IndexerClusterSpecVolumesStorageosSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesStorageosSecretRef)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesStorageosSecretRefArgs) ToIndexerClusterSpecVolumesStorageosSecretRefOutput() IndexerClusterSpecVolumesStorageosSecretRefOutput {
	return i.ToIndexerClusterSpecVolumesStorageosSecretRefOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesStorageosSecretRefArgs) ToIndexerClusterSpecVolumesStorageosSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosSecretRefOutput)
}

func (i IndexerClusterSpecVolumesStorageosSecretRefArgs) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutput() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesStorageosSecretRefArgs) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosSecretRefOutput).ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesStorageosSecretRefPtrInput is an input type that accepts IndexerClusterSpecVolumesStorageosSecretRefArgs, IndexerClusterSpecVolumesStorageosSecretRefPtr and IndexerClusterSpecVolumesStorageosSecretRefPtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesStorageosSecretRefPtrInput` via:
//
//          IndexerClusterSpecVolumesStorageosSecretRefArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesStorageosSecretRefPtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutput() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput
	ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(context.Context) IndexerClusterSpecVolumesStorageosSecretRefPtrOutput
}

type indexerClusterSpecVolumesStorageosSecretRefPtrType IndexerClusterSpecVolumesStorageosSecretRefArgs

func IndexerClusterSpecVolumesStorageosSecretRefPtr(v *IndexerClusterSpecVolumesStorageosSecretRefArgs) IndexerClusterSpecVolumesStorageosSecretRefPtrInput {
	return (*indexerClusterSpecVolumesStorageosSecretRefPtrType)(v)
}

func (*indexerClusterSpecVolumesStorageosSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesStorageosSecretRef)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesStorageosSecretRefPtrType) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutput() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return i.ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesStorageosSecretRefPtrType) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesStorageosSecretRefPtrOutput)
}

// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
type IndexerClusterSpecVolumesStorageosSecretRefOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesStorageosSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesStorageosSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesStorageosSecretRefOutput) ToIndexerClusterSpecVolumesStorageosSecretRefOutput() IndexerClusterSpecVolumesStorageosSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosSecretRefOutput) ToIndexerClusterSpecVolumesStorageosSecretRefOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosSecretRefOutput) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutput() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o.ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesStorageosSecretRefOutput) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageosSecretRef) *IndexerClusterSpecVolumesStorageosSecretRef {
		return &v
	}).(IndexerClusterSpecVolumesStorageosSecretRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesStorageosSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesStorageosSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IndexerClusterSpecVolumesStorageosSecretRefPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesStorageosSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesStorageosSecretRef)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesStorageosSecretRefPtrOutput) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutput() IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosSecretRefPtrOutput) ToIndexerClusterSpecVolumesStorageosSecretRefPtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesStorageosSecretRefPtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesStorageosSecretRefPtrOutput) Elem() IndexerClusterSpecVolumesStorageosSecretRefOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageosSecretRef) IndexerClusterSpecVolumesStorageosSecretRef {
		return *v
	}).(IndexerClusterSpecVolumesStorageosSecretRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o IndexerClusterSpecVolumesStorageosSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesStorageosSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesVsphereVolume struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType *string `pulumi:"fsType"`
	// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
	StoragePolicyID *string `pulumi:"storagePolicyID"`
	// Storage Policy Based Management (SPBM) profile name.
	StoragePolicyName *string `pulumi:"storagePolicyName"`
	// Path that identifies vSphere volume vmdk
	VolumePath string `pulumi:"volumePath"`
}

// IndexerClusterSpecVolumesVsphereVolumeInput is an input type that accepts IndexerClusterSpecVolumesVsphereVolumeArgs and IndexerClusterSpecVolumesVsphereVolumeOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesVsphereVolumeInput` via:
//
//          IndexerClusterSpecVolumesVsphereVolumeArgs{...}
type IndexerClusterSpecVolumesVsphereVolumeInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesVsphereVolumeOutput() IndexerClusterSpecVolumesVsphereVolumeOutput
	ToIndexerClusterSpecVolumesVsphereVolumeOutputWithContext(context.Context) IndexerClusterSpecVolumesVsphereVolumeOutput
}

// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesVsphereVolumeArgs struct {
	// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType pulumi.StringPtrInput `pulumi:"fsType"`
	// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
	StoragePolicyID pulumi.StringPtrInput `pulumi:"storagePolicyID"`
	// Storage Policy Based Management (SPBM) profile name.
	StoragePolicyName pulumi.StringPtrInput `pulumi:"storagePolicyName"`
	// Path that identifies vSphere volume vmdk
	VolumePath pulumi.StringInput `pulumi:"volumePath"`
}

func (IndexerClusterSpecVolumesVsphereVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesVsphereVolume)(nil)).Elem()
}

func (i IndexerClusterSpecVolumesVsphereVolumeArgs) ToIndexerClusterSpecVolumesVsphereVolumeOutput() IndexerClusterSpecVolumesVsphereVolumeOutput {
	return i.ToIndexerClusterSpecVolumesVsphereVolumeOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesVsphereVolumeArgs) ToIndexerClusterSpecVolumesVsphereVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesVsphereVolumeOutput)
}

func (i IndexerClusterSpecVolumesVsphereVolumeArgs) ToIndexerClusterSpecVolumesVsphereVolumePtrOutput() IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(context.Background())
}

func (i IndexerClusterSpecVolumesVsphereVolumeArgs) ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesVsphereVolumeOutput).ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(ctx)
}

// IndexerClusterSpecVolumesVsphereVolumePtrInput is an input type that accepts IndexerClusterSpecVolumesVsphereVolumeArgs, IndexerClusterSpecVolumesVsphereVolumePtr and IndexerClusterSpecVolumesVsphereVolumePtrOutput values.
// You can construct a concrete instance of `IndexerClusterSpecVolumesVsphereVolumePtrInput` via:
//
//          IndexerClusterSpecVolumesVsphereVolumeArgs{...}
//
//  or:
//
//          nil
type IndexerClusterSpecVolumesVsphereVolumePtrInput interface {
	pulumi.Input

	ToIndexerClusterSpecVolumesVsphereVolumePtrOutput() IndexerClusterSpecVolumesVsphereVolumePtrOutput
	ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(context.Context) IndexerClusterSpecVolumesVsphereVolumePtrOutput
}

type indexerClusterSpecVolumesVsphereVolumePtrType IndexerClusterSpecVolumesVsphereVolumeArgs

func IndexerClusterSpecVolumesVsphereVolumePtr(v *IndexerClusterSpecVolumesVsphereVolumeArgs) IndexerClusterSpecVolumesVsphereVolumePtrInput {
	return (*indexerClusterSpecVolumesVsphereVolumePtrType)(v)
}

func (*indexerClusterSpecVolumesVsphereVolumePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesVsphereVolume)(nil)).Elem()
}

func (i *indexerClusterSpecVolumesVsphereVolumePtrType) ToIndexerClusterSpecVolumesVsphereVolumePtrOutput() IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return i.ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(context.Background())
}

func (i *indexerClusterSpecVolumesVsphereVolumePtrType) ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterSpecVolumesVsphereVolumePtrOutput)
}

// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
type IndexerClusterSpecVolumesVsphereVolumeOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesVsphereVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterSpecVolumesVsphereVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesVsphereVolumeOutput) ToIndexerClusterSpecVolumesVsphereVolumeOutput() IndexerClusterSpecVolumesVsphereVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesVsphereVolumeOutput) ToIndexerClusterSpecVolumesVsphereVolumeOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumeOutput {
	return o
}

func (o IndexerClusterSpecVolumesVsphereVolumeOutput) ToIndexerClusterSpecVolumesVsphereVolumePtrOutput() IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return o.ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(context.Background())
}

func (o IndexerClusterSpecVolumesVsphereVolumeOutput) ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesVsphereVolume) *IndexerClusterSpecVolumesVsphereVolume {
		return &v
	}).(IndexerClusterSpecVolumesVsphereVolumePtrOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesVsphereVolumeOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesVsphereVolume) *string { return v.FsType }).(pulumi.StringPtrOutput)
}

// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
func (o IndexerClusterSpecVolumesVsphereVolumeOutput) StoragePolicyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesVsphereVolume) *string { return v.StoragePolicyID }).(pulumi.StringPtrOutput)
}

// Storage Policy Based Management (SPBM) profile name.
func (o IndexerClusterSpecVolumesVsphereVolumeOutput) StoragePolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesVsphereVolume) *string { return v.StoragePolicyName }).(pulumi.StringPtrOutput)
}

// Path that identifies vSphere volume vmdk
func (o IndexerClusterSpecVolumesVsphereVolumeOutput) VolumePath() pulumi.StringOutput {
	return o.ApplyT(func(v IndexerClusterSpecVolumesVsphereVolume) string { return v.VolumePath }).(pulumi.StringOutput)
}

type IndexerClusterSpecVolumesVsphereVolumePtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterSpecVolumesVsphereVolumePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterSpecVolumesVsphereVolume)(nil)).Elem()
}

func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) ToIndexerClusterSpecVolumesVsphereVolumePtrOutput() IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) ToIndexerClusterSpecVolumesVsphereVolumePtrOutputWithContext(ctx context.Context) IndexerClusterSpecVolumesVsphereVolumePtrOutput {
	return o
}

func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) Elem() IndexerClusterSpecVolumesVsphereVolumeOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesVsphereVolume) IndexerClusterSpecVolumesVsphereVolume { return *v }).(IndexerClusterSpecVolumesVsphereVolumeOutput)
}

// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) FsType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesVsphereVolume) *string {
		if v == nil {
			return nil
		}
		return v.FsType
	}).(pulumi.StringPtrOutput)
}

// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) StoragePolicyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesVsphereVolume) *string {
		if v == nil {
			return nil
		}
		return v.StoragePolicyID
	}).(pulumi.StringPtrOutput)
}

// Storage Policy Based Management (SPBM) profile name.
func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) StoragePolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesVsphereVolume) *string {
		if v == nil {
			return nil
		}
		return v.StoragePolicyName
	}).(pulumi.StringPtrOutput)
}

// Path that identifies vSphere volume vmdk
func (o IndexerClusterSpecVolumesVsphereVolumePtrOutput) VolumePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterSpecVolumesVsphereVolume) *string {
		if v == nil {
			return nil
		}
		return &v.VolumePath
	}).(pulumi.StringPtrOutput)
}

// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
type IndexerClusterStatus struct {
	// current phase of the cluster master
	ClusterMasterPhase *string `pulumi:"clusterMasterPhase"`
	// Indicates if the cluster is ready for indexing.
	Indexing_ready_flag *bool `pulumi:"indexing_ready_flag"`
	// Indicates if the cluster is initialized.
	Initialized_flag *bool `pulumi:"initialized_flag"`
	// Indicates if the cluster is in maintenance mode.
	Maintenance_mode *bool `pulumi:"maintenance_mode"`
	// status of each indexer cluster peer
	Peers []IndexerClusterStatusPeers `pulumi:"peers"`
	// current phase of the indexer cluster
	Phase *string `pulumi:"phase"`
	// current number of ready indexer peers
	ReadyReplicas *int `pulumi:"readyReplicas"`
	// desired number of indexer peers
	Replicas *int `pulumi:"replicas"`
	// selector for pods, used by HorizontalPodAutoscaler
	Selector *string `pulumi:"selector"`
	// Indicates whether the master is ready to begin servicing, based on whether it is initialized.
	Service_ready_flag *bool `pulumi:"service_ready_flag"`
}

// IndexerClusterStatusInput is an input type that accepts IndexerClusterStatusArgs and IndexerClusterStatusOutput values.
// You can construct a concrete instance of `IndexerClusterStatusInput` via:
//
//          IndexerClusterStatusArgs{...}
type IndexerClusterStatusInput interface {
	pulumi.Input

	ToIndexerClusterStatusOutput() IndexerClusterStatusOutput
	ToIndexerClusterStatusOutputWithContext(context.Context) IndexerClusterStatusOutput
}

// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
type IndexerClusterStatusArgs struct {
	// current phase of the cluster master
	ClusterMasterPhase pulumi.StringPtrInput `pulumi:"clusterMasterPhase"`
	// Indicates if the cluster is ready for indexing.
	Indexing_ready_flag pulumi.BoolPtrInput `pulumi:"indexing_ready_flag"`
	// Indicates if the cluster is initialized.
	Initialized_flag pulumi.BoolPtrInput `pulumi:"initialized_flag"`
	// Indicates if the cluster is in maintenance mode.
	Maintenance_mode pulumi.BoolPtrInput `pulumi:"maintenance_mode"`
	// status of each indexer cluster peer
	Peers IndexerClusterStatusPeersArrayInput `pulumi:"peers"`
	// current phase of the indexer cluster
	Phase pulumi.StringPtrInput `pulumi:"phase"`
	// current number of ready indexer peers
	ReadyReplicas pulumi.IntPtrInput `pulumi:"readyReplicas"`
	// desired number of indexer peers
	Replicas pulumi.IntPtrInput `pulumi:"replicas"`
	// selector for pods, used by HorizontalPodAutoscaler
	Selector pulumi.StringPtrInput `pulumi:"selector"`
	// Indicates whether the master is ready to begin servicing, based on whether it is initialized.
	Service_ready_flag pulumi.BoolPtrInput `pulumi:"service_ready_flag"`
}

func (IndexerClusterStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterStatus)(nil)).Elem()
}

func (i IndexerClusterStatusArgs) ToIndexerClusterStatusOutput() IndexerClusterStatusOutput {
	return i.ToIndexerClusterStatusOutputWithContext(context.Background())
}

func (i IndexerClusterStatusArgs) ToIndexerClusterStatusOutputWithContext(ctx context.Context) IndexerClusterStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterStatusOutput)
}

func (i IndexerClusterStatusArgs) ToIndexerClusterStatusPtrOutput() IndexerClusterStatusPtrOutput {
	return i.ToIndexerClusterStatusPtrOutputWithContext(context.Background())
}

func (i IndexerClusterStatusArgs) ToIndexerClusterStatusPtrOutputWithContext(ctx context.Context) IndexerClusterStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterStatusOutput).ToIndexerClusterStatusPtrOutputWithContext(ctx)
}

// IndexerClusterStatusPtrInput is an input type that accepts IndexerClusterStatusArgs, IndexerClusterStatusPtr and IndexerClusterStatusPtrOutput values.
// You can construct a concrete instance of `IndexerClusterStatusPtrInput` via:
//
//          IndexerClusterStatusArgs{...}
//
//  or:
//
//          nil
type IndexerClusterStatusPtrInput interface {
	pulumi.Input

	ToIndexerClusterStatusPtrOutput() IndexerClusterStatusPtrOutput
	ToIndexerClusterStatusPtrOutputWithContext(context.Context) IndexerClusterStatusPtrOutput
}

type indexerClusterStatusPtrType IndexerClusterStatusArgs

func IndexerClusterStatusPtr(v *IndexerClusterStatusArgs) IndexerClusterStatusPtrInput {
	return (*indexerClusterStatusPtrType)(v)
}

func (*indexerClusterStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterStatus)(nil)).Elem()
}

func (i *indexerClusterStatusPtrType) ToIndexerClusterStatusPtrOutput() IndexerClusterStatusPtrOutput {
	return i.ToIndexerClusterStatusPtrOutputWithContext(context.Background())
}

func (i *indexerClusterStatusPtrType) ToIndexerClusterStatusPtrOutputWithContext(ctx context.Context) IndexerClusterStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterStatusPtrOutput)
}

// IndexerClusterStatus defines the observed state of a Splunk Enterprise indexer cluster
type IndexerClusterStatusOutput struct{ *pulumi.OutputState }

func (IndexerClusterStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterStatus)(nil)).Elem()
}

func (o IndexerClusterStatusOutput) ToIndexerClusterStatusOutput() IndexerClusterStatusOutput {
	return o
}

func (o IndexerClusterStatusOutput) ToIndexerClusterStatusOutputWithContext(ctx context.Context) IndexerClusterStatusOutput {
	return o
}

func (o IndexerClusterStatusOutput) ToIndexerClusterStatusPtrOutput() IndexerClusterStatusPtrOutput {
	return o.ToIndexerClusterStatusPtrOutputWithContext(context.Background())
}

func (o IndexerClusterStatusOutput) ToIndexerClusterStatusPtrOutputWithContext(ctx context.Context) IndexerClusterStatusPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *IndexerClusterStatus {
		return &v
	}).(IndexerClusterStatusPtrOutput)
}

// current phase of the cluster master
func (o IndexerClusterStatusOutput) ClusterMasterPhase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *string { return v.ClusterMasterPhase }).(pulumi.StringPtrOutput)
}

// Indicates if the cluster is ready for indexing.
func (o IndexerClusterStatusOutput) Indexing_ready_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *bool { return v.Indexing_ready_flag }).(pulumi.BoolPtrOutput)
}

// Indicates if the cluster is initialized.
func (o IndexerClusterStatusOutput) Initialized_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *bool { return v.Initialized_flag }).(pulumi.BoolPtrOutput)
}

// Indicates if the cluster is in maintenance mode.
func (o IndexerClusterStatusOutput) Maintenance_mode() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *bool { return v.Maintenance_mode }).(pulumi.BoolPtrOutput)
}

// status of each indexer cluster peer
func (o IndexerClusterStatusOutput) Peers() IndexerClusterStatusPeersArrayOutput {
	return o.ApplyT(func(v IndexerClusterStatus) []IndexerClusterStatusPeers { return v.Peers }).(IndexerClusterStatusPeersArrayOutput)
}

// current phase of the indexer cluster
func (o IndexerClusterStatusOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

// current number of ready indexer peers
func (o IndexerClusterStatusOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *int { return v.ReadyReplicas }).(pulumi.IntPtrOutput)
}

// desired number of indexer peers
func (o IndexerClusterStatusOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *int { return v.Replicas }).(pulumi.IntPtrOutput)
}

// selector for pods, used by HorizontalPodAutoscaler
func (o IndexerClusterStatusOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *string { return v.Selector }).(pulumi.StringPtrOutput)
}

// Indicates whether the master is ready to begin servicing, based on whether it is initialized.
func (o IndexerClusterStatusOutput) Service_ready_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatus) *bool { return v.Service_ready_flag }).(pulumi.BoolPtrOutput)
}

type IndexerClusterStatusPtrOutput struct{ *pulumi.OutputState }

func (IndexerClusterStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexerClusterStatus)(nil)).Elem()
}

func (o IndexerClusterStatusPtrOutput) ToIndexerClusterStatusPtrOutput() IndexerClusterStatusPtrOutput {
	return o
}

func (o IndexerClusterStatusPtrOutput) ToIndexerClusterStatusPtrOutputWithContext(ctx context.Context) IndexerClusterStatusPtrOutput {
	return o
}

func (o IndexerClusterStatusPtrOutput) Elem() IndexerClusterStatusOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) IndexerClusterStatus { return *v }).(IndexerClusterStatusOutput)
}

// current phase of the cluster master
func (o IndexerClusterStatusPtrOutput) ClusterMasterPhase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *string {
		if v == nil {
			return nil
		}
		return v.ClusterMasterPhase
	}).(pulumi.StringPtrOutput)
}

// Indicates if the cluster is ready for indexing.
func (o IndexerClusterStatusPtrOutput) Indexing_ready_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Indexing_ready_flag
	}).(pulumi.BoolPtrOutput)
}

// Indicates if the cluster is initialized.
func (o IndexerClusterStatusPtrOutput) Initialized_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Initialized_flag
	}).(pulumi.BoolPtrOutput)
}

// Indicates if the cluster is in maintenance mode.
func (o IndexerClusterStatusPtrOutput) Maintenance_mode() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Maintenance_mode
	}).(pulumi.BoolPtrOutput)
}

// status of each indexer cluster peer
func (o IndexerClusterStatusPtrOutput) Peers() IndexerClusterStatusPeersArrayOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) []IndexerClusterStatusPeers {
		if v == nil {
			return nil
		}
		return v.Peers
	}).(IndexerClusterStatusPeersArrayOutput)
}

// current phase of the indexer cluster
func (o IndexerClusterStatusPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

// current number of ready indexer peers
func (o IndexerClusterStatusPtrOutput) ReadyReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *int {
		if v == nil {
			return nil
		}
		return v.ReadyReplicas
	}).(pulumi.IntPtrOutput)
}

// desired number of indexer peers
func (o IndexerClusterStatusPtrOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *int {
		if v == nil {
			return nil
		}
		return v.Replicas
	}).(pulumi.IntPtrOutput)
}

// selector for pods, used by HorizontalPodAutoscaler
func (o IndexerClusterStatusPtrOutput) Selector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *string {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(pulumi.StringPtrOutput)
}

// Indicates whether the master is ready to begin servicing, based on whether it is initialized.
func (o IndexerClusterStatusPtrOutput) Service_ready_flag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexerClusterStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Service_ready_flag
	}).(pulumi.BoolPtrOutput)
}

// IndexerClusterMemberStatus is used to track the status of each indexer cluster peer.
type IndexerClusterStatusPeers struct {
	// The ID of the configuration bundle currently being used by the master.
	Active_bundle_id *string `pulumi:"active_bundle_id"`
	// Count of the number of buckets on this peer, across all indexes.
	Bucket_count *int `pulumi:"bucket_count"`
	// Unique identifier or GUID for the peer
	Guid *string `pulumi:"guid"`
	// Flag indicating if this peer belongs to the current committed generation and is searchable.
	Is_searchable *bool `pulumi:"is_searchable"`
	// Name of the indexer cluster peer
	Name *string `pulumi:"name"`
	// Status of the indexer cluster peer
	Status *string `pulumi:"status"`
}

// IndexerClusterStatusPeersInput is an input type that accepts IndexerClusterStatusPeersArgs and IndexerClusterStatusPeersOutput values.
// You can construct a concrete instance of `IndexerClusterStatusPeersInput` via:
//
//          IndexerClusterStatusPeersArgs{...}
type IndexerClusterStatusPeersInput interface {
	pulumi.Input

	ToIndexerClusterStatusPeersOutput() IndexerClusterStatusPeersOutput
	ToIndexerClusterStatusPeersOutputWithContext(context.Context) IndexerClusterStatusPeersOutput
}

// IndexerClusterMemberStatus is used to track the status of each indexer cluster peer.
type IndexerClusterStatusPeersArgs struct {
	// The ID of the configuration bundle currently being used by the master.
	Active_bundle_id pulumi.StringPtrInput `pulumi:"active_bundle_id"`
	// Count of the number of buckets on this peer, across all indexes.
	Bucket_count pulumi.IntPtrInput `pulumi:"bucket_count"`
	// Unique identifier or GUID for the peer
	Guid pulumi.StringPtrInput `pulumi:"guid"`
	// Flag indicating if this peer belongs to the current committed generation and is searchable.
	Is_searchable pulumi.BoolPtrInput `pulumi:"is_searchable"`
	// Name of the indexer cluster peer
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Status of the indexer cluster peer
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (IndexerClusterStatusPeersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterStatusPeers)(nil)).Elem()
}

func (i IndexerClusterStatusPeersArgs) ToIndexerClusterStatusPeersOutput() IndexerClusterStatusPeersOutput {
	return i.ToIndexerClusterStatusPeersOutputWithContext(context.Background())
}

func (i IndexerClusterStatusPeersArgs) ToIndexerClusterStatusPeersOutputWithContext(ctx context.Context) IndexerClusterStatusPeersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterStatusPeersOutput)
}

// IndexerClusterStatusPeersArrayInput is an input type that accepts IndexerClusterStatusPeersArray and IndexerClusterStatusPeersArrayOutput values.
// You can construct a concrete instance of `IndexerClusterStatusPeersArrayInput` via:
//
//          IndexerClusterStatusPeersArray{ IndexerClusterStatusPeersArgs{...} }
type IndexerClusterStatusPeersArrayInput interface {
	pulumi.Input

	ToIndexerClusterStatusPeersArrayOutput() IndexerClusterStatusPeersArrayOutput
	ToIndexerClusterStatusPeersArrayOutputWithContext(context.Context) IndexerClusterStatusPeersArrayOutput
}

type IndexerClusterStatusPeersArray []IndexerClusterStatusPeersInput

func (IndexerClusterStatusPeersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterStatusPeers)(nil)).Elem()
}

func (i IndexerClusterStatusPeersArray) ToIndexerClusterStatusPeersArrayOutput() IndexerClusterStatusPeersArrayOutput {
	return i.ToIndexerClusterStatusPeersArrayOutputWithContext(context.Background())
}

func (i IndexerClusterStatusPeersArray) ToIndexerClusterStatusPeersArrayOutputWithContext(ctx context.Context) IndexerClusterStatusPeersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexerClusterStatusPeersArrayOutput)
}

// IndexerClusterMemberStatus is used to track the status of each indexer cluster peer.
type IndexerClusterStatusPeersOutput struct{ *pulumi.OutputState }

func (IndexerClusterStatusPeersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexerClusterStatusPeers)(nil)).Elem()
}

func (o IndexerClusterStatusPeersOutput) ToIndexerClusterStatusPeersOutput() IndexerClusterStatusPeersOutput {
	return o
}

func (o IndexerClusterStatusPeersOutput) ToIndexerClusterStatusPeersOutputWithContext(ctx context.Context) IndexerClusterStatusPeersOutput {
	return o
}

// The ID of the configuration bundle currently being used by the master.
func (o IndexerClusterStatusPeersOutput) Active_bundle_id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *string { return v.Active_bundle_id }).(pulumi.StringPtrOutput)
}

// Count of the number of buckets on this peer, across all indexes.
func (o IndexerClusterStatusPeersOutput) Bucket_count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *int { return v.Bucket_count }).(pulumi.IntPtrOutput)
}

// Unique identifier or GUID for the peer
func (o IndexerClusterStatusPeersOutput) Guid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *string { return v.Guid }).(pulumi.StringPtrOutput)
}

// Flag indicating if this peer belongs to the current committed generation and is searchable.
func (o IndexerClusterStatusPeersOutput) Is_searchable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *bool { return v.Is_searchable }).(pulumi.BoolPtrOutput)
}

// Name of the indexer cluster peer
func (o IndexerClusterStatusPeersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Status of the indexer cluster peer
func (o IndexerClusterStatusPeersOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexerClusterStatusPeers) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type IndexerClusterStatusPeersArrayOutput struct{ *pulumi.OutputState }

func (IndexerClusterStatusPeersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexerClusterStatusPeers)(nil)).Elem()
}

func (o IndexerClusterStatusPeersArrayOutput) ToIndexerClusterStatusPeersArrayOutput() IndexerClusterStatusPeersArrayOutput {
	return o
}

func (o IndexerClusterStatusPeersArrayOutput) ToIndexerClusterStatusPeersArrayOutputWithContext(ctx context.Context) IndexerClusterStatusPeersArrayOutput {
	return o
}

func (o IndexerClusterStatusPeersArrayOutput) Index(i pulumi.IntInput) IndexerClusterStatusPeersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexerClusterStatusPeers {
		return vs[0].([]IndexerClusterStatusPeers)[vs[1].(int)]
	}).(IndexerClusterStatusPeersOutput)
}

func init() {
	pulumi.RegisterOutputType(IndexerClusterTypeOutput{})
	pulumi.RegisterOutputType(IndexerClusterMetadataOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecIndexerClusterRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecIndexerClusterRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecLicenseMasterRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecLicenseMasterRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecResourcesOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecResourcesPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecResourcesLimitsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecResourcesRequestsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplatePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateMetadataOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecPortsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecPortsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecPortsTargetPortOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecPortsTargetPortPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecSelectorOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateSpecSessionAffinityConfigClientIPPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusLoadBalancerOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusLoadBalancerPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecServiceTemplateStatusLoadBalancerIngressArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAwsElasticBlockStoreOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAwsElasticBlockStorePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAzureDiskOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAzureDiskPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAzureFileOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesAzureFilePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCephfsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCephfsPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCephfsSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCephfsSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCinderOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCinderPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCinderSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCinderSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesConfigMapOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesConfigMapPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesConfigMapItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesConfigMapItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCsiOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCsiPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCsiNodePublishSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCsiNodePublishSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesCsiVolumeAttributesOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsFieldRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesDownwardAPIItemsResourceFieldRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesEmptyDirOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesEmptyDirPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFcOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFcPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlexVolumeOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlexVolumePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlexVolumeOptionsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlexVolumeSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlexVolumeSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlockerOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesFlockerPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGcePersistentDiskOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGcePersistentDiskPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGitRepoOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGitRepoPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGlusterfsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesGlusterfsPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesHostPathOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesHostPathPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesIscsiOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesIscsiPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesIscsiSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesIscsiSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesNfsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesNfsPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPersistentVolumeClaimOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPersistentVolumeClaimPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPhotonPersistentDiskOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPhotonPersistentDiskPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPortworxVolumeOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesPortworxVolumePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesConfigMapOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesConfigMapPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesConfigMapItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsFieldRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesSecretOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesSecretPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesSecretItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesSecretItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesProjectedSourcesServiceAccountTokenPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesQuobyteOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesQuobytePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesRbdOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesRbdPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesRbdSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesRbdSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesScaleIOOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesScaleIOPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesScaleIOSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesScaleIOSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesSecretOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesSecretPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesSecretItemsOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesSecretItemsArrayOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesStorageosOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesStorageosPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesStorageosSecretRefOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesStorageosSecretRefPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesVsphereVolumeOutput{})
	pulumi.RegisterOutputType(IndexerClusterSpecVolumesVsphereVolumePtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterStatusOutput{})
	pulumi.RegisterOutputType(IndexerClusterStatusPtrOutput{})
	pulumi.RegisterOutputType(IndexerClusterStatusPeersOutput{})
	pulumi.RegisterOutputType(IndexerClusterStatusPeersArrayOutput{})
}
